# -*- coding: utf-8 -*-
"""Preprocessing MYE Clean Code Main.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Slg54v2dtqKOnY2LPeOorMfGxLFjdENX
"""

from google.colab import drive
drive.mount('/content/drive')

"""#**Install Packages**"""

!pip install mne

"""# **Import Modules**"""

# In[] Imports modules
import mne
import pickle
import numpy as np
import os

"""# **Processing Variables**"""

# Root where the raw data are stored in our case on google colab
root_dir = "/gdrive/MyDrive/FYPD_Dataset/"

# Root where the structured data will be saved - It can be changed and saved in other direction means after cleaning the data
save_dir = root_dir + "derivatives2/"

# Subjects and blacks
N_Subj_arr = [1,2,3,4,5,6,7,8,9,10]  # N_S---> No.of people
N_block_arr = [1,2,3]               # N_B---> No.of blocks/sessions

##################### Filtering
# Cut-off frequencies
Low_cut = 0.5
High_cut = 100

# 45 freq mili hai

# Apply a notch filter to remove interference at a specific frequency. here we apply a Notch filter in 50Hz

Notch_bool = True

# Downsampling rate
DS_rate = 4

##################### ICA
# If False, ICA is not applyed
ICA_bool = True
ICA_Components = None
ica_random_state = 23
ica_method = 'infomax'
max_pca_components = None
fit_params = dict(extended=True)

##################### EMG Control
low_f = 1
high_f = 20
# Slide window desing
# Window len (time in sec)
window_len = 0.5
# slide window step (time in sec)
window_step = 0.05

# Threshold
std_times = 3

# Baseline
t_min_baseline = 0
t_max_baseline = 15

# Trial time
t_min = 1
t_max = 3.5

# In[]: Fixed Variables
# Events ID
# Trials tag for each class.
# 31 = Arriba / Up
# 32 = Abajo / Down
# 33 = Derecha / Right
# 34 = Izquierda / Left
event_id = dict(Arriba = 31, Abajo = 32, Derecha = 33, Izquierda = 34)

#Baseline id
baseline_id = dict(Baseline = 13)

# Report initialization
report = dict(Age = 0, Gender = 0, Recording_time = 0,  Ans_R = 0, Ans_W = 0)

# Montage
Adquisition_eq = "biosemi128"
# Get montage
montage = mne.channels.make_standard_montage(Adquisition_eq)

# Extern channels
Ref_channels = ['EXG1', 'EXG2']

# Gaze detection
Gaze_channels = ['EXG3','EXG4']

# Blinks detection
Blinks_channels = ['EXG5','EXG6']

# Mouth Moving detection
Mouth_channels = ['EXG7','EXG8']

# Demographic information
Subject_age = [56,50,34,24,31,29,26,28,35,31]

Subject_gender = ['F','M','M','F','F','M','M','F','M','M']

"""# **File Path**"""

file_name = "/content/drive/MyDrive/FYPD_Dataset/sub-01/ses-01/eeg/sub-01_ses-01_task-innerspeech_eeg.bdf"
N_S = 2
N_B =1
datatype="eeg"

"""# **Read Data from BDF File**




"""

# Load the data
rawdata = mne.io.read_raw_bdf(input_fname=file_name, preload=True,verbose='WARNING')


# Plot the raw EEG data
rawdata.plot()

"""# **Set Referencing**

Ref_channels = ['EXG1', 'EXG2']

Extern channels in an EEG device typically refer to channels that are external to the main EEG electrode array. These channels are used to capture additional physiological signals or external events that may be relevant to the EEG recording or experimental setup.

The main EEG electrode array consists of electrodes placed on the scalp to capture electrical activity generated by the brain. These electrodes record neural signals, which are then processed and analyzed to study brain activity.

Electromyography (EMG): These channels capture muscle activity. EMG signals can be useful for detecting muscle artifacts that may arise from facial muscles, neck muscles, or other muscles near the scalp.
"""

rawdata.set_eeg_reference(ref_channels=Ref_channels)

"""# **Notch filter**
Notch filters are particularly useful for removing unwanted interference or noise at specific frequencies, a notch filter might be applied to remove interference caused by electrical equipment or other environmental factors, providing a cleaner representation of the underlying physiological signals. Here it is 50hz as mentioned in paper
"""

if Notch_bool:
  # Notch filter
  rawdata = mne.io.Raw.notch_filter(rawdata,freqs=50)
rawdata.plot()

"""# **Filtering raw data**
Digital filtering
The data were filtered with a zero-phase bandpass finite impulse response filter using the corresponding MNE function. The lower and upper bounds were set to 0.5 and 100 Hz, respectively. This broad band filter aims to keep the data as raw as possible, allowing future users the possibility of filtering the data in their desired bands. A Notch filter in 50 Hz was also applied.
"""

rawdata.filter(Low_cut, High_cut)
rawdata.plot()

"""# **Get events**
Subject 10  on Block 1 have a spureos trigger
"Spurious triggers" refer to false or undesired events that are erroneously detected or recorded in the EEG data.

## **Raw data event tags number and meanings.**
![image.png](data:image/png;base64,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)

![image.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABJIAAALICAYAAAAkKNq0AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAGjpSURBVHhe7d29cipJmzbqp/c54C0LOTvw8GQRMWPjiQNA3rJk4skZeZiy2hMHIHnYMxFYsj6sj9iOsJY1HETvyqoCCgQopaW/7r6uN3gbBNRPVhVLeSuf5I+/CvEBFotF+d9Op1P+F3ibdC25jgAAADjmMzOY/6f+LwAAAACcJEgCAAAAIMuHl7YBAAAA8PE+o7TNHEnwzZkjCQAAgFPMkQQAAADAtyNIAgAAACCLIAkAAACALIIkAAAAALIIkgAAAADIIkgCAAAAIIsgCQAAAIAsgiQAAAAAsgiSAAAAAMgiSAIAAAAgiyAJAAAAgCyCJAAAAACyCJIAAAAAyCJIAgAAACCLIAkAAACALIIkAAAAALIIkgAAAADIIkgCAAAAIIsgCQAAAIAsgiQAAAAAsgiSAAAAAMgiSAIAAAAgiyAJAAAAgCxfFyStHuLy7CzO1rebef1EbX6zfa647T8NJPO4uXyIVfG/h8ub4tGe+jo7dP2sHi6fX3fZivX+xnU5v6nfu/85UN++9npPbXkZD6vGdr7Za9opvbZa7z/e5rh/7f6m4/v2a+CTpX8Ty2sdAAC+1pcFSavZIvqPT/H0lG73MZwMGp2toiM37cRj+VxxexzHcvAv6WDBa8ynMWm3o7WaxbTdj27947X5n6NoD4cxmb53Z7kb18W1eb2/whyrh7idDKO/ee8w7tfX+uZ6/8oO/q8oPp2i15rHdGc7d+UFcb/RTu/s94LDWhkAHQgsX6X4fB8V5+V9Ot53cdGqf/wFutfFNrzi4KTg6dI/RAAA/Mt9WZDUurhudCC60R9GLJfrX9BbcXF9Ufx/rXURV8OiozzzCzw0zaeTGPa7sZpNIzo/6p+u1UHIdT+Gk9tvE8SW2zr++Sz02iiu97syXP6ibZ5PY9nvRWu1jOXweTjH7/oVi1nv+ekKAAD8LXyPOZLqEQpXR/80vYrlMqLd/sI/XcM3lEZUpAEVrYu7uNu/ftJopTIISUHt8SC2HKmyLivbG7Gy81xx2xk1eLlXsrVXjnp49MsqUo7U7710LR/a5qpMbLuO7ciY/ZEi5XY3y4CaZUH1/fmx/e5eV22ZAq0jo1XS+s5Hs4jJoHx/9fa6TR7qsq1NyeHzdju0D++lLNdaL7/e58PbW7fTZlt2j2c1gumh3t7LePifot3ORzGLSQzS65sv3rG/j43RpOWIpkGxhFmMzovnmsdoz85+1O1UbVNzvQfOw73z5NQIot3l1aWF82a55fr4VOsZTCJmo/Pi580RssfXd7AN9/d5p2Rt7xw/0T4AAPBVvjBIanQ2RhHjp+vjf/mf/xmj2fESE+C59WilpNsfxmw6e94pnQxiFOO6rOwxxstBoyO8itmivykxfRz3YnJ7pGObOsODZYw35ar7y6qla7ksG6sfn/Cj0yvW/6t+lDrYg1iOH+vlp+1ZxqDuaO/uXwqrZkWPfxrrHGq1XEYvjTKqHqY0IG7X+/04jt5Oae3LUoCX2iOG9+UymnnTJA24Ssu9a4yqXFvNYtFf70PRRr1J3J4IOl6tOA6D5Xh7zK7a5Y8Pb2/G8a12pnj+Li7+47pqq3Up4sGQLX2un8eoXa2nvN23Y3ReBzLr0WbFUspz5VAbFVKINIjtMh7HnfqZl1TnSbGB9Xvvoz0avWJk2yxGt/Xxq4/PoDwxWnFx9xT3w4heeQ6uS/Iy1rfThv0YNs7Lsr1ui+v0qm6HefHaxrKGxXn65yvOSwAA+AxfGCRVv5iXvzCPI0Zn+39Vrm06qCeCJmDX/jxE3f0ObG143xjJVFyTV81AZrfEtNXrR2+2iHW005RCq9543ChX3V9WpQy31p3m10ijq3rjGDdGXbUurrb7VO7fetvSHEfFa4ezqHKoA6OgmssqS2ebpbW/5+T+Feu6brR3Cre2Ydk7aRyjVrd7oq0zju/w6nVzGKW5umbDuG+GTN2fZSCTPU1Xfe42l9G6uMj7/K/Pk5+bF3fjZ/HvS35ZdC/G43WbVOdwGg579N0569tpw72RdnV7ba/T60YouV/yDQAA38P3KG1Lf6W+Hz77a3hZ2nCbJt3+2glZ4e8mzUO0KUEqb3U50UvDG350iq50Qwpy18soy5oOOVJ6mpa1E0ycnrx636/FLHr1RDppRFGxgr1Q5Ed0euuwKN2vw4qic5/mOLooeuHlJOOps545CuozNEu2ynKzTLulXs3SqobudTzdR33cj7ymKev4vsKvRcx6neJoNLXSocsPRA4uI095nsxGcb5pp6qN3z2sq71lfd0qaSr/rXs+X1hjpG5xS6V0AADw3XyPIOmA1Gm67TweLX0AjqlKu4abEpn6VpZwTasSo2NSJ76+W4YMZZDbeH/91K4TQUEjEFg93NZzNmXYmzetVa1gJ2iurCdtrkb3pOBoPl1Wo4/SKKW0v2mfnoVQX2PzuVa3aVlulqn8hrH1sTgVrqcwqTxe/ZienwiTso/vKzwLD7ey57g7sYyXlOdJXb63cztYhvf73rS+Vi+KIxOz1f5IuaoscHG1XU4qpQMAgO/mi4Kk4hfmm+boo3ncDCbbOUxenHwbOGq/XGYtdWD3S4x2vhmtug7XpVn7o4CqUU6HlXMU7cwNU1zjxeNihfX7q07zeFsDdFwKOM7T18M3ylnL0rVRjBqpyOqheNwYaVSWZi1v43a5/lkqDVrGbZqDJncY1IfaH7lVBX7vafVwsz0GrXa067uHvOb4ZqvPsWpeoVpxPAevGIl2aBmrh4cyAC2Dm0YYWp4DzY0uw8PXzXf1W960vhR6Rkz//HNvpNz+t9mlEXz1XQAA+Ea+KEhqFR2cZjlANYnu7rdONcty6ptvsIEXzf8cxezgyJ961E6zhLR4XYzW11h1Ha4HU5RzENXf8pVuo0X7+IiVsqQqTaq8XtZ5TPuNa/pkednetV6Pktkd1NGN63Ii4/SNWdXrzqf9eGyOWCxHeswa4VU5uCVmHzRRf7N98oKEas6dyWC9r6NYtH97DNCOVrs4nJtjkCaB3o5c2t/eVx3ftXI+qfp4HdzpYh/vqonW18ut5qJ+zRx3z5dxPk3Fi4XiPLtfr7+4jeIqdgd1FefJ4ziWmzZOt4wSv0xlWdrOt7a9bX0p9IzJJNo782lV8yttj1+x00YkAQDwDf3xV6G+/64Wi0X5304n99t2gEPStfT9rqP0bVW30XnMm79sXdK1GxYDAADwHj4zg/m2cyQB31j5bVXHRhjtqybZVqoKAADw9ydIAvKtv+VrsGx8TfpLUlnaa0qbAAAA+K4ESUC+9TeCnfrWMAAAAP6xBEkAAAAAZBEkAQAAAJBFkAQAAABAFkESAAAAAFkESQAAAABkESQBAAAAkEWQBAAAAEAWQRIAAAAAWQRJAAAAAGQRJAEAAACQRZAEAAAAQBZBEgAAAABZBEkAAAAAZBEkAQAAAJBFkAQAAABAFkESAAAAAFkESQAAAABkESQBAAAAkEWQBAAAAECWP/4q1Pff1WKxqO8BAAAA8NE6nU597+N8eJD0GTsB/2TpWnIdAQAAcMxnZjBK2wAAAADIIkgCAAAAIIsgCQAAAIAsgiQAAAAAsgiSAAAAAMgiSAIAAAAgiyAJAAAAgCyCJAAAAACyCJIAAAAAyCJIAgAAACCLIAkAAACALIIkAAAAALIIkgAAAADIIkgCAAAAIIsgCQAAAIAsgiQAAAAAsgiSAAAAAMgiSAIAAAAgiyAJAAAAgCyCJAAAAACyCJIAAAAAyCJIAgAAACDL1wVJq4e4PDuLs/XtZl4/UVk9XG6fK257TwOledxcPsSq+N/D5U3xqP7pTePaWt/K132VYjvPLuPhPTZgflN/XqR93t/PbRsk5efIa/Y7Lfu17ZQ+y8r3pH3cXf+rlZ+Lme30lm39u0r7euD4fq50fP8+/xaV575/OAEA+ABfFiStZovoPz7F01O63cdwMmj8gr6K2aIfj+Vzxe1+GJPBV3Yg4JuaT2PSbkdrNYtpux/d+sdJb/xYX1/V7b49ivP3CnO+zCoebicx7G/3dHjf2MfhJAaNcKV1cRdPdxfRqh//vgOB2K9FRL8XrXQshrvHoCmFe5cvNX7rIu6e7uLi/Tb4zbK29wXvE2YUbT5Yxrj89+L6aPt+vG5cF+fY9Ss24D3aEAAAvpsvC5JaF9eNzlI3+sOI5XLT/YuL60bnr9uPYSxj8zRQmk+rUGU1m0Z0ftQ/Pax7/RSP44jRn3/jSDYFZjGOn0c6892f4+jNFvGrfvwZ5tNl9HutWC2XOwEX72RVfPZHO9rfIFwDAAC+yxxJq4e4nQzj6sif4VcPtzEZXn2Lv9LDd5LCoTRCIo28ucu4QFq9fvQm08bovr3ysObokbp06qEuk9s8tSkzSrfnI5x2y+r2RhL+apa07j23s9zDIznKwCyN/qkfv+hZ+dfu/t7MD5fc/WqW1q53vCw7G8QkZjE6L35eL7d7XY0gSsfg8GiVap2DScRsdF4sc72+et0P9X6X69nfnvS43o50+4BStp3jVS7/2PamJjhWcly95+ahPr7Fcv6nWO75aBYxGey9dt/ePjbPi3T8zkdFi09ikJ47upC987hup+cjgg4c7xfO5616H9ebUJ9b80Pnyok2PL6+w224fx3s7NPOsox+AgDgc3xhkNT4xX8UMd4vWWjMoTSKcTy9pp4AOKzVjvZmdF+6Bs9j2l+XwD3GeNksMS3MRrHoV2Vj5SWYOq6DiPu6lOzpvh2j0TbcSJ3cQdzXy0sjoDr1M8ksRrfpWq/X1ZvEoLGy+bS53GGx6j+3gUJpHn8WnxVp9M9hxf6M0ofJzyPlT/v7+xT9aQqG9hT7fJs+c9JrHsfRW5fdlmVn9zGMXlVmlV0y14qLu1R2ty43bJauFW2y6FfrOvQZVzVKvb3Fuotte9cBZcXxHCzHmzLix6t28cNj27tbcvw47sXkdjfYmhSbWx7fom3+oxwB10u1h+XrD3+Ep2BnEMtGGebjeLktT+xeV8egaPXy3Di4kOfH9b5fP/WSF87nFx07V461Ycb6dtqwX1wH09n2+b0/urx8zQAAwPv7wiCp+kW7/AU4lduc7f3Fuuy0Vc+PYxRfO8kq/AOlMrFZcyRgcU1eDYuObONK6+2WkaVSul4zqOn+LK7PacxST7fu5N43Ovuti4tGqNOL8XgdvlTriuVy00nuXjfC5EPlrOUcRM9HJk4G6xEZZSJ9fGTWs/1N60zB0J5in8fr1xSfQ9VmNjfkPRVtcqxOL+leNwKY/RLgd9IoBWx1u/XxOaQ4Zo2S43J0214Z4fDqlfNRpWPabO9C6+IqhrP6nMox/7P8Y0NzGd3ivMvZjpPnc45Xnis569tpw3QdNNoijcibNebhevGaAQCAD/A9SttSaHRfdGD3/rq9lkpG0iS6t4btw+9pzjfza7EtGVrfUi1OI9zZtUpPRVWqs37PeYxms1ikNCEtr9eJ0zM1ndAYhXhWlpDtWs8HtW892XY5/9Op0SS/u31fojFys7ilw5MnsyQujfi5j/ocOFXWVWuWUpUlZ78nzSsVabL4+nHlR3R69TmV4fAycrxwPr+7t6yvGz+L83paJbWRKjt3gscXrhkAAPgI3yNIAj7FPNWGrUdE/OhEr7cta9rcjpZstVJ/fedb0ta3ctRMWt5bJ7pOHeLzRVxtlrk3Uqge7XRqLuvWxbgcvTg6lYbsb18ZrH1XVcnW4mrbzqlUKk/1DWPr950sw0thUnrNYz+m5yfCpBQi3Xa250tZcvZ7WumEWh4KLnsvzR2/cXwZL3nhfH53b1tfGvkVqbytnGi+H5vKzpeuGQAA+CBfFCQVHaSb5l/I53EzmERvPYlu8QvyTbM3k+bxmPROzI0CnFaNbEnz4WxLcYpr6qXgZU+3P4zJ4EiZaVre3rxHq4eHvJLU/dFCqeSpvpuUk2wfnftorRUX43JY0uEwpCz92R3ZmIK13x1V83F+xWLWDFTmMX3nISerh5ttW5XzZx23P/KnLLOq779ZWbq1ew6uHorHzcDkJQeWMS/Ou/ToR6e3M8fQ/GZ31M7J8/kDvGl95XU6jT//LK6B5kTzL1wzAADwUb4oSGoVHZZRnDeG5KfJVjdzmxQdmmgO/x8sY/zYnKAWeMl+CU05smVnZEqap+w+2juvO/XtWoXudTUZcuP127KptLxqwu71c+dF3zdrYEk5V0zjM6F433Z0RVXSkxUkty6izJLOD3XWu3Fd1r9t93faf+0ojqrUqPmtbbm61RuL9WaUkJUa6yq3d6dR3kX1UbtefpoFevs5u7+95dxF9Tewpdto0X5xRFLzPYfPqzRyavccPJ/24/HUCKpnni9jUGxbev96lNr6vHp2vE+ez7/v2TF/0/pakQYlTSbt3W82PXnNAADAx/njr0J9/10tFovyv51O81ubgNdK19K/+jpal1S9KlzItCkP2vvWSAAAgL+Rz8xgzJEEfGvlJNuv/TawLKt4GI12vgULAACA0wRJwLfWvX6vyY93vwGt/Mas9n08fczMygAAAP9IStvgm/vXl7YBAABwktI2AAAAAL4dQRIAAAAAWQRJAAAAAGQRJAEAAACQRZAEAAAAQBZBEgAAAABZBEkAAAAAZBEkAQAAAJBFkAQAAABAFkESAAAAAFkESQAAAABkESQBAAAAkEWQBAAAAEAWQRIAAAAAWQRJAAAAAGQRJAEAAACQRZAEAAAAQBZBEgAAAABZBEkAAAAAZPnjr0J9/10tFov6HgAAAAAfrdPp1Pc+zocHSZ+xE/BPlq4l1xEAAADHfGYGo7QNAAAAgCyCJAAAAACyCJIAAAAAyCJIAgAAACCLIAkAAACALIIkAAAAALIIkgAAAADIIkgCAAAAIIsgCQAAAIAsgiQAAAAAsgiSAAAAAMgiSAIAAAAgiyAJAAAAgCyCJAAAAACyCJIAAAAAyCJIAgAAACCLIAkAAACALIIkAAAAALIIkgAAAADIIkgCAAAAIIsgCQAAAIAsgiQAAAAAsnxdkLR6iMuzszhb327m9RPPzW+K5y8fYlU/BtbmcVNeG6t4uLwpHtU/La6Zy4fPuGKK9RfX74nL9w3SMi/j9Zuf2qB+3/zmNz4z0nKqz6VjbZjaN+3z6uHyt9u5/HzLbMC0vtzX/r29fAw+Q9nef5t/e9563QAAwOt8WZC0mi2i//gUT0/pdh/DyeBwZ3T1ELeT+j6waz6NSbsdrdUspu1+dOsff55uXBfX8PXnr/i5+Z8xin70WvXjN1o9jGLUvi8/m+4uioWVofc2pCt+EMvlMPrdVcymEf2jK8zr2Hevi8/A79GA7xBEvE+Y8ewYfJHWxV083V1E9hY8O1cAAOCf58uCpNbFdWz7B93oD6PonD3vfcz/HEV7WDwJPDOfTmLY78YqJRqdH/VP/53Ktrh6Raf/iF+LWfROteUmtPsVi3cIrnjuxWMAAAB8me8xR1I56mgYV/t/eZ7fxGA5jp/9+jGwI41mSYNZ0siJYyM3yvKcdQnp+tYY/rfz/OVDPDTL4g6MsNgtr6pKkHZGE6ayss26mqNT6tc+1GWtm5KhbRlTul0+LMufbu0+f3ZwxMc8psVnSD9zYM9um6yXV61nMImYjc6Lnxfb/j/FvpyPYhaTGKTXph1tXcRdOYKoG9fHRquU7TYo3jWL0Xnxvnpfq7Yr2rjcn6ptdttzf9veu2ywUG7b3vKPbG9q11S6uNmeZplXXT6YzpdyOf99bBkH7JwjxW2zkweOwbGF7C2jWsSBEVH1dm5/tHc+nWrgnfdW77uZN9uksa702v1zpXRqffX2PtT7cvPf9Trqp0vr9W7vb5Zl9BMAAF/gC4Okxi/Eo4jx0/VeWU7xC/ZgGePx748wgH+zsjynLCEtbo/j6MUw7utSqhRanE/78bh+/moRo98pJU2d6UHE/Xp59+0YjXYDhck0Xe/Fc2UIkz4HzmPaf9xs49ViVHTFG1azWGyef4xxbxK3e+nC6uE2JsO80r79fX4cL2NQ9tJbcXH3FPfDiN44re8uLv7jettm6fW5JWgpbEolu8U7x6mEtxk4VQ1QLf/Zh9sqZovmtvVicnsikHm1or1Ho2jfV8tPZcVlTn9se+fFtjZeO5yN4s9mclE8XvSr56//88Q+N5XnSPHZviltLo7pclCHlweOwaGF7J9nxTHq1E+dtn++VeveDW5Omwym0a/Xez+cbc/v7qFzJWd9xTKKY14+f/2f0esXx3zaeEFZsjmOn+XiXr4WAADgo31hkFR1GMpfiMcRo7Pdv8LObwaxHI8PdyKAN1iHCOvQNs3xM9stBys6w6kT/1apvKw3/rkNdLo/iy7wNGaNvu7O+lKZ2Gx3NGL3OoURDa2LuN483yo72rPFr/pxUs1VNC572i95vs+ti6sYTqafN7JjeHXic634XLxubFuvH73ZIpp7+x62ZcTd6J5qtuJ82GZnB0qQe3XA8QrVOdL8bC/2+WpYHpe8SKQ4j28nMdycx4XiHLnIOvz751u17p3g5gXN9XZ/jk8fn6z19XbO3fKYN87Hsr2Kc75cwovXAgAAfLzvUdqW/hpe9F7Xf3lPIwZSSdv4eG8LeKX5TTUyYhsM/IrFrPeOUyulSajXJUnr0pvzGM1mcbSv+2sRs14nXtqE8pvN6mWej2b1T2ups549V1Ha5zSqZLu8s7IcaxkHpmj7Gmm0zXrbylKpPHklcSnAf4z+tD5GLw7FSSNqtstMJWe/pzpH2u29g/Wj84rA7DfO23S+FUe7LD1b39JOFRv1IYf/Lesr/j28Gk6iypqqks1m0HryWgAAgE/wPYKkHdWIgVQycd78xbt8fGK+DOC4eTXf2G44+yM6vf2Qp+rov00r2u00YqMeadi4Ha0IOxQgrJbR3ITUcb7trMt5qnKvpjQhf6xHbLwo7XNdetXYvqMlVJ8thUi3nW2pYVkqlWenhLG4Ha/CS2FS9Zr7GJwIk6qyrMXVdpm/M1qtUp0jh75YITICxcqh8zZTOt964237rm/HyvB+1xvX1+3Xo5bStzI2SjZfuhYAAOAzfFGQVHRQbprzfqT5kNbD97ednM2tmjCj+GX8m3T24O8kTaR8cL6xqlO/MwdPmo+lOcih1Y52rEdHFIpljU6Mgig7wINXTABcL785z0sKhrZr2B/BUgfNG89HbJyWyoHi2bxN38Wq2tnNcUrfxne8td+i+KxtBEc/OqeCiP2RP6mt67u/IZ0js9Go8UeBquQyPwysSrp2zrPivHwoH1Qh03RTS1n927LR6kU/RjH6rL9IvHV93X5ZbnmTvolwM4P8S9cCAAB8ji8KkooObPHL9WbE0VmaD+nx6LdOAW9VddJnxf/Kb9JaX3P1N1Glb327bzeuxWl/b9RJN65T2em6FKzo71+dGgXRva4mr14vL91OfXtXWv7TfbQb5XDTfnOOpFY1p8ymFG0Ui3Zj/XsjNnY0RzWmW70daeTOzj6n26kSr7rUaPebuHJ042ea/+2lbzBrqOZrGmy2a7RoZ49IyvMjOsvt8stJxzdDl/a3t/G4fP00dievOiRjn9Ok1GkS9s1yq5LL13z+p2O4c56dF9tWBl7F+TIuN2Czzf2dEzr9oWL3fEu3Vx3WU56dK29dX5qPahKT9K2lm5P7hWsBAAA+yR9/Fer772qxWJT/7XTyvksHOCxdS595Ha3LZ75/sLstvTpexgUAAPDP95kZzDecIwkgQznJ9uu/NQwAAIC3EyQBf0/p2x4/apJkAAAADhIkATvSvEnmKwMAAOAQQRIAAAAAWQRJAAAAAGQRJAEAAACQRZAEAAAAQBZBEgAAAABZBEkAAAAAZBEkAQAAAJBFkAQAAABAFkESAAAAAFkESQAAAABkESQBAAAAkEWQBAAAAEAWQRIAAAAAWQRJAAAAAGQRJAEAAACQRZAEAAAAQBZBEgAAAABZBEkAAAAAZBEkAQAAAJDlj78K9f13tVgs6nsAAAAAfLROp1Pf+zgfHiR9xk7AP1m6llxHAAAAHPOZGYzSNgAAAACyCJIAAAAAyCJIAgAAACCLIAkAAACALIIkAAAAALIIkgAAAADIIkgCAAAAIIsgCQAAAIAsgiQAAAAAsgiSAAAAAMgiSAIAAAAgiyAJAAAAgCyCJAAAAACyCJIAAAAAyCJIAgAAACCLIAkAAACALIIkAAAAALIIkgAAAADIIkgCAAAAIIsgCQAAAIAsgiQAAAAAsgiSAAAAAMgiSAIAAAAgy/cIkuY3cXZ2GQ+r+nFS/uxsc7uZ1z8Hdu1dK2ff9WLZbOdNuJxPm9987HH86OW/q3TeXD5E858HAADg63yDIGkVD7eT+v5a8bNpJx6fnuIp3R7HsRzsBU1ArB4u4+y2ca0Ut/vOctPpToHB5W9eOOU6fjt0mMfNYBnjx7SN19Gtf/q3t3qIy98Oxoq22QvSu9dFO11/XCu9dvnvcw4AAAD/BF8fJM3/jFF7GMP6YaUVF9cXxf/XWhdxNZzFdCZJgqZfi1n0+r3ttVLoXjSune9itYxltKP97TYMAACA1/jiIKkepfCzXz8+ZhXLZURbLxR2/Oj0YjadHSj7WcXD5VkMJhGz0XlsS0ern29L4Zqjaarnbh7SKJviucuH+J+bszgfzSImg/L1xwelpFE1R5abSpPORzGLSQzSc0cXsrdtjXKmckTMZtn7o6zqET3zervL2/NRQmU516Hnd0oDmyOD6vaYN/et8fzB/XrehuXLd9bR2P5yRNOgWMIsRufb1z8fAXSifQvr1zf38dRItN3ln26/tMzD58DuNjXXVy3/oT6exbL/v7TsvWOyM5prb/+UsgEAwPf11wf5v//3/5a3U/7Pf7X/Gt7/b7r313+1h3+Vdw/5P//1V7v9X8Wr4N8n5zpqt9fX0q7tNVb73/u//mvz+H//uh82n68et4f3xb2t/70f/tX+r1NXX7p+d9dTvqe5nGK9w5PX8P62FEu9r95fLmvnvdX6tptUPd6ur96PxjaXbdR4/L/FsstH+58t6fH+chrPl8s5uV+H2/D//NfeOp7tz+7n326bv9y+VRs12qRcx/HP1EPLP9V+u69PDh2D7fqq7Wmuv1pmcxE752axvbvL2tuXvfYEAAB25WQw7+XrRiTNb2KwHMf44oVRRukv+eXcKv+geVXgHZXz3Tw9Rn/aHHl0ROsirjfXXKssi5stftWPK8OrV5bGzacx6e1ey62LqxjOppFdjZpKXGN3GVWJ3qoccTW8b17/3fg57sVk2hzf0ovxeL3drbi4GkYaxliufvUQt5Nh3DfmBGoVy06P5tNJ9MY/t8vu/iy2Yne7m+vu/hxHb7aI3RZ7br8Nu9eN7e/2YxjLWGa3TWb7Du9js4tpP3qz2Du0J5xov0Pqbfq53animMRu+fHwKrabXJ1r22M2j+mkF/1e/YLu9Xbbi2X1y9XnNhAAAPCZviZISiUNKRzadFwOK8s0yomE7xodEuC5ovN/9xRP9+0Yne+VEO1plj+VJUu/aVXVne5dyz+i84og4/Aykl+xmPWi86N+WGsVrz0ZdDT9WsSs1ym2aF9VMluV/q3b5DxGs9cEMJnKMq71OlIpW773aN/3Vm7TbBTnm32qzqX9ULKpDL8m0+rcTEHUTtC0W9aYSjIBAIDv6UuCpFX6S/p6TpCy47CdI2Q9z0bq7N52HuPp7nTYBDS8MNplc13V3/D2OO7Vz7zd8VDneQB0zPFlnAhMDgZPB/zoHBlF1EqLiOF91RbN27t+YVoKkc4XcbVZ/v3elwuc9h7t+97KbRre77RZeTvZcGmk0STSoKQ0EmzYX782hUjnsbjaLuf+NQ0EAAB8qi8JkloXd7udj7Jj1Su/Gvwu/Ym6LkW5MgwJTprf7I0+SiM9jn472v6k9VXZ2G9L4dVsFKOdyZaLx9GPdeXSiw4sY/6QJlyuS6IGzf2cx82gGUS8oJVKqCYxaExevSqWnR51+8O9ZX+A/RFR5TF6hfdo3/eWtmkyODH5+mFle09vYlp8vm8P3/6os1T2Vt8FAAC+nS/+1rZT6m9Cat58kw/s+NFZ7l4ng4j7p905fWLzrW3V3DeTwfr1o1i0Xx6RVJUknfrWtm5cP91Hu1Eidj7tx+OrRhM+X8ZgUY04SsHz47i5n+VOvmLUUCr7e4zxstqHavvSWKdC93pv2cXtNZ8zrYu4Gr7wbXTlvEuNMrBi3bsDbqr5hZrf2rbrPdr39zw/B4ptehzHcnMupdsL83MlZQA1iWVzXqrm/pfLedZAAADAN/JHmnG7vv+uFotF+d9Op1P+F3ibdC25jgAAADjmMzOYbzwiCQAAAIDvRJAEAAAAQBZBEgAAAABZBEkAAAAAZBEkAQAAAJBFkAQAAABAFkESAAAAAFkESQAAAABkESQBAAAAkEWQBAAAAEAWQRIAAAAAWQRJAAAAAGQRJAEAAACQRZAEAAAAQBZBEgAAAABZBEkAAAAAZBEkAQAAAJBFkAQAAABAFkESAAAAAFkESQAAAABkESQBAAAAkOWPvwr1/Xe1WCzqewAAAAB8tE6nU9/7OB8eJH3GTsA/WbqWXEcAAAAc85kZjNI2AAAAALIIkgAAAADIIkgCAAAAIIsgCQAAAIAsgiQAAAAAsgiSAAAAAMgiSAIAAAAgiyAJAAAAgCyCJAAAAACyCJIAAAAAyCJIAgAAACCLIAkAAACALIIkAAAAALIIkgAAAADIIkgCAAAAIIsgCQAAAIAsgiQAAAAAsgiSAAAAAMgiSAIAAAAgiyAJAAAAgCyCJAAAAACyCJIAAAAAyCJIAgAAACDL9wiS5jdxdnYZD6v68Z75zVmcXT7Ekafh3628foprZH27mddPfDOb7byJj9zC1cPlh35efPTy39c8bk58tgIAALzWNwiSVvFwO6nvH7B6iFNPw79ZGWrcduLx6Sme6tt9Z7kJOVIIe/mbKUK5jt8Op+ZxM1jG+DFt43V065/+vudBSeviLp7uLqJVP35vr15+8Rl2+cHhGQAAwGf5+iBp/meM2sMY1g/3zf8cRXt47Fn4d/u1mEWv39sJNboXHxeivNlqGctoR/vbbRgAAACv8cVBUj1K4We/frxnfhOD5TiOPQ3/dj86vZhNZwfKrFbxcHkWg0nEbHQe29LR6ufbUrjmSJnquZuHNIKmeO7yIf7n5izOR7OIyaB8/fGBSWlk0JHlppK281HMYhKD9NyRhZQjnxrL2H9ZWeK6eb5YfjnSZ1AsdRaj8+Jn63KztL6d0rP9fd4r9apfP2+u/9QIrJ3l1202b+5/Y/lH931vm5rrq5f/UO/vzX8fGNG0M8rp1DEFAAB4X18aJM1vBrEcj+Pi4CiFOmQaf8PRFfBNpDKr+/Yozs/2S9hacXH3FPfDiN74MZ6e7qrrbDWLRT89TiVmjzHuTeJ2530Rk2nEOD1/dxH/cf0Uj+NexPC+fM/1wZq0FKKka3m93PSeZQzWYUv3Op4ex9GLYdyn5w8uZBWzRX9TopfWObndhkEpRBpEtQ3V852083H3dF8stVeVzB0sN0shy3mM2tv3Pt23Y3S+F7bMRnEb4+r5tK2TwYnQ7LnJYBr9evn3w1mMRqf2vdqmafM4LPfWV2zPol8t7/o/e9EvjtO08XwaqRnjn1WJYMYxBQAAeC9fFyTNq9FG48Mp0gshE7DWva4ChP60OfLoiNZFXG8uqlZZFjdb/KofV4ZXrwxv59OY9Hav5dbFVQxn05hl5xmtuLjerrfV60dvtohyy8p50oZx3wigWhcXefMsrWYxne2+N7o/y7ClGcxEc/uLNroaRiyX+WHM8H4771P353i77YfU23TVOA4XxQonzQ0qtufnZpOr47R9fh7TSQqXttv70jEFAAB4L18TJKWyjBOjjVKJy6mQCdhXjUA6ONpmT7NErCxb+02r5TKi3d67ln9EpzeLV+UZqaRrXZ5VloPVfi1i1usUS3yDg+9tpc19VVD0rtI2rUvd1rdUg1i047EtKoO5ybQ6rim4G17thOzvfUwBAACO+ZIgaZVGKqznNSk7P9t5Ti4f/r9yzpdU2pHKdTadrPLxC6Mt4N+u249hLONYRpICh9tOswStVz/zdq0qlTkQgvSik5v+pBCp+e1zZTlY7Ufn9AifU068t/1VM3+nbeqNd75pr7yd/Ca4bvSH1Siq+XQSw/52hNVHHFMAAIBjviRIKr8+u9mBasxzcnfx/1YjK5rPVxO9FB2vep4XoDS/2Rt9lEarHP12tFXKexoByqoKbX9XCq9moxg1Ut7VQ/E4+rGuvnrJ/qimKmyutao5ggaNSYRWDw8nR11tHHhvCq0Gk2E0spjPlbapaJ1me+Xo9lP5201Md7b9g44pAADAEV862Tbwe350lnslUhH3T7vz9cTmW9vquXgG69ePYtF+efRKVVZ16lvbunH9dB/tcj3Vss+n/Xg8OcJmV3Md6TZatLcjkoqlXNxVE1Jvl5+K55JuVLtY/Hznm9rWnr93v40+XDnnUvNb29I27bZXuh1u24YU2E0msVxPsl162zEFAAB4qz/+KtT339VisSj/2+l0yv8Cb5OuJdcRAAAAx3xmBmNEEgAAAABZBEkAAAAAZBEkAQAAAJBFkAQAAABAFkESAAAAAFkESQAAAABkESQBAAAAkEWQBAAAAEAWQRIAAAAAWQRJAAAAAGQRJAEAAACQRZAEAAAAQBZBEgAAAABZBEkAAAAAZBEkAQAAAJBFkAQAAABAFkESAAAAAFkESQAAAABkESQBAAAAkEWQBAAAAEAWQRIAAAAAWf74q1Dff1eLxaK+BwAAAMBH63Q69b2P8+FB0mfsBPyTpWvJdQQAAMAxn5nBKG0DAAAAIIsgCQAAAIAsgiQAAAAAsgiSAAAAAMgiSAIAAAAgiyAJAAAAgCyCJAAAAACyCJIAAAAAyCJIAgAAACCLIAkAAACALIIkAAAAALIIkgAAAADIIkgCAAAAIIsgCQAAAIAsgiQAAAAAsgiSAAAAAMgiSAIAAAAgiyAJAAAAgCyCJAAAAACyCJIAAAAAyCJIAgAAACCLIAkAAACALIIkAAAAALJ8jyBpfhNnZ5fxsKofJ+XPzhq3veeByv61cjOvn/hmNtt5E++xhauHy3ff13KZlw/x9/iomceNz0UAAOCTfYMgaRUPt5P6/tZquYwY3sfT01N9u4uLVv0kUCqDj9tOPG6uk6e47yw3Qcj85iwufzNpeJ/AZh43g2WMH9M2Xke3/ul307q4i6e7i8j+qFk9xOU7BWMAAAB/B18fJM3/jFF7GMP6YVOv86O+BxzyazGLXr+3E3x0L14RhHyW1TKW0Y62MBgAAOBv7YuDpHqUws9+/XgrdZCB0350ejGbzg6UYq3i4fIsBpOI2eg8tqWh1c+3pXDN0TTVczcPaZRN8dzlQ/zPzVmcj4prcTIoX398YFIqszqy3FTSdj6KWUxikJ47uJC6TOuhLn/bvGZ3uadGV5UjpxqvXS/iWbnaoVLatfTc5rV1e8yb29B439H92mvj5v7Wy38o2rXcxv8+MKJpZ5TTqeMFAADw+b40SJrfDGI5Hh8tWas6wHWHS+8JnkmlWPftUZwX18huyNKKi7unuB9G9MaP29LQ1SwW/fQ4lZg9xrg3idu9RGUyjRin5+8u4j+un+Jx3NuUmV4frElLQUu6ltfLTe9ZxmAdyHSv4+lxHL0Yxn16/vBCCrMYLfrVMsrXVMst3lQv9z7ao9GROYFWMSveuy7xS9s8ua3Wv26jUfnGVVlKO7zPL5WdDKbRr5d7Pyy2cXRqv1Lwcx7TZhsvB7ufX7NRcQyq5V3/Zy/6xTGYNp6f/zkqDsDPqvwv43gBAAB8pq8LkuY3MViOY3ykN9ctOrBV56m4FZ215UCYBIdU18pj9KfNkUdHtC7ienPNtcqyuNniV/24Mrx6ZWncfBqT3u613Lq4iuFsGrNXZR69GP9shEz1crc/6sbPccT04EJbcXG93e5Wrx+92SLWe9ZNbxz9GQ8Poxi1748EYocN77dzOqXlNJf7zGpWbN8wrhptfHE1jEkzKdrZp+oYbJ+fx3SSwqX6/RnHCwAA4DN9TZCUSjdSSds4s8NadKbGaYRBszMGNFQjkJ7u2zE6P13+lCbgXo/0K8vWflM5MX67vXct/4hObxa/k3mUy51Vo62a23s0SClL1urXliVnDeVnyDJGo3bcvyZFeq1fi22p2/qW6guLfTmWqZWh22RaHbMUng2vdkZLvffxAgAA+B1fEiSt0kiFVMZyvu4gDYquV/X41BwoJt+GF3T7MYxlLI9cRimUuO00S9B69TNv12q3jwQlvfidS7Zc7s43N9a3Q0FQCpGa315Xlpw1zePPUTuGww8uDfvRiV5vvPMteuXt5DfBdaNfbFfKyefTSQz72/37iOMFAADwO74kSCq/YrvZyXq6Lzq/vfKrwe/KP8Wv4uGhMaZi9RCjUWzLPYDS/GZv9FEa0XL029FWKe+J9ubJVTlR929L4dVsPQdRZZVKyKIfv3XJpuVO9uYXOmJ/VFQVVq+leYvSXEvXcX19ap6ld9DqFXu92xY5uv1U/nYT08kwtjnSBx0vAACA3/Clk22fNK2+Jaq8nU+j/5g/OS78W/zoLPfKqNLc1Ltz+sTmW9vq+XoG69ePYtF+eYRLVXp16lvbunFdToS9nRz/fNqPx5OjcHIUy63nR1sv99gcUM1tTLfRor0ZkTS/OY9RrOclKpZZlv+9MJdUrtZFXA2b39qWSgx32yLdXgzDytBsEsv1JNultx0vAACAj/THX4X6/rtaLBblfzudTvlf4G3SteQ6AgAA4JjPzGC+74gkAAAAAL4VQRIAAAAAWQRJAAAAAGQRJAEAAACQRZAEAAAAQBZBEgAAAABZBEkAAAAAZBEkAQAAAJBFkAQAAABAFkESAAAAAFkESQAAAABkESQBAAAAkEWQBAAAAEAWQRIAAAAAWQRJAAAAAGQRJAEAAACQRZAEAAAAQBZBEgAAAABZBEkAAAAAZBEkAQAAAJBFkAQAAABAlj/+KtT339VisajvAQAAAPDROp1Ofe/jfHiQ9Bk7Af9k6VpyHQEAAHDMZ2YwStsAAAAAyCJIAgAAACCLIAkAAACALIIkAAAAALIIkgAAAADIIkgCAAAAIIsgCQAAAIAsgiQAAAAAsgiSAAAAAMgiSAIAAAAgiyAJAAAAgCyCJAAAAACyCJIAAAAAyCJIAgAAACCLIAkAAACALIIkAAAAALIIkgAAAADIIkgCAAAAIIsgCQAAAIAsgiQAAAAAsgiSAAAAAMgiSAIAAAAgiyAJAAAAgCzfI0ia38TZ2WU8rOrHG/O4OTsrnqtuN/P6x8BWef1sr5Oz73qhbLbzpriyv1L1ufK3+TxJ7Xb5EM8+HgEAAL7ANwiSVvFwO6nvN6we4vJsEHH/FE9P1e26Wz8HlFYPl3F224nH+hpJt/vOchM6zG/O4vJ5Qvsq5Tp+O3WZx81gGePHtI3X8aGXcvnZcSqs6sb1Kz9P3qMdAQAA/gm+Pkia/xmj9jCG9cO1+Z+jKHqdwiM44ddiFr1+L1r146R7cbHz+FtYLWMZ7Wh/uw0DAADgNb44SKpHKfzs14/X5jGdDOPqQq8TTvnR6cVsOjtQ9rSKh8uzGEwiZqPz2JaOVj/flsI1R+5Uz908pBE9xXOXD/E/N2dxPppFTAbl648PTNotQ91ZbirNOh/FLCYxSM8dXEh6f7GND3X52+Y1u8vdGRVUjjzaPle+JWtd9X5uVlGVjs3TyKv18jZPHmvH5Pi2VaO4Huq2Lt7zPwfK05ola+n+kWUBAAB8J18aJM1vBrEcj+NZXpRGL/Q6UfTCtp0rc4TAM62Lu7hvj+L8WfjQiou7p7gfRvTGj/H0dFddZ6tZLPrpcSoxe4xxbxK3e6HFZBoxTs/fXcR/XD/F47gXMbwv33N4hGAKVNK1vF5ues8yButrtnsdT4/j6MUw7tPzR4cZzmK06FfLKF9TLXdb3nof7dFoG4gV99uN58o4Ontde2ajuI1xtaz0/smgDpqOtOPJbatVDVm95z/6MZxNY7Z5vtj+20kMr6rRY/PipeX2pluxstnoz2INAAAA38/XBUnzmxgsxzE+Nuqo2bErbmVn+eDoAvh3616na+Qx+tP9ETMHtC7ienPNtcqyuNniV/24sg43ss2nMentXsuti6u94CRHL8Y/G8FPvdztj7rxcxwxbSx0uVzf70Y3MzM6qLn9RRtdDZvLPiBj24qGbITk3egPZ9vnV+n+MPr1+7vXjXmjuv0YxjJOrR4AAOCrfE2QlEpSUknb+FSHdbe0rVv00nqTqb/Sw0HVyJmn+3aMzk9/K1qaOHo90q8sW/tNq+Uyot3eu5Z/RKc3i72M6lXK5c6q0VbN7a2Cr7S/6/CseO6TQ+bT23ZY+gyLugxxNUujlX5uw6OdMr1BHPj6AQAAgG/hS4Kk1IkqulxFh7fZcaoel+U5rXa069cCr/DCaJYUIt12miVovfqZt2u1i6t1uf2muK1edH7Ud9+gXG5dUrdz25Sr1eFZ8bP7GHxqmPTyth3Q6kU/0iitVaQcqd+ro7cUIp0v4mqznPviGAIAAHxPXxIkpXlddjtgqePUK78a/K4chZTKQCYxaHQM07e4zYb97V/wgZjf7I0+SiVXR78dbZXynmhvnkyBxu+PSCrDq9koRo2autVD8Tj6sc5K3iQtdzNX0b553DSeSJOOf6qT23ZMKiWMmP75Z0ybbfNrEbNeJzaZW3kMAQAAvqcvnWz7lDTvSznKoC73GBSPsifOhX+JH51l9e1k61s5//N2vp2ynGrzbWOtuLgaxmSwfv0oFu2XA5hyvqOT39rWjetysum6zKy4nU/78Xj3yrmWnimW+ziO5WZ70209B9SP6Cy3nw/l+tafD+UcR6e+te31dtux/MmJbTuulZKkySTazXmouj9jHI0yuWkq7AUAAPie/virUN9/V4vFovxvp9Mp/wu8TbqWXEcAAAAc85kZzLcdkQQAAADA9yJIAgAAACCLIAkAAACALIIkAAAAALIIkgAAAADIIkgCAAAAIIsgCQAAAIAsgiQAAAAAsgiSAAAAAMgiSAIAAAAgiyAJAAAAgCyCJAAAAACyCJIAAAAAyCJIAgAAACCLIAkAAACALIIkAAAAALIIkgAAAADIIkgCAAAAIIsgCQAAAIAsgiQAAAAAsgiSAAAAAMjyx1+F+v67WiwW9T0AAAAAPlqn06nvfZwPD5I+YyfgnyxdS64jAAAAjvnMDEZpGwAAAABZBEkAAAAAZBEkAQAAAJBFkAQAAABAFkESAAAAAFkESQAAAABkESQBAAAAkEWQBAAAAEAWQRIAAAAAWQRJAAAAAGQRJAEAAACQRZAEAAAAQBZBEgAAAABZBEkAAAAAZBEkAQAAAJBFkAQAAABAFkESAAAAAFkESQAAAABkESQBAAAAkEWQBAAAAEAWQRIAAAAAWQRJAAAAAGQRJAEAAACQ5QuDpHncnJ3FWeN2+bCqn2tKr7sp/h84aH6zcx2d3XzTq2WznQeu59VDXJ5dxsGPAN7d6uEyzi4f4u/R3OnfAOcGAAB8F18XJK2WsYxh3D89xVN9u7to1U9Wys7O2SAm9WNgV3mN3HbisXEd3XeWm4BgfnMsoM1XruO3w6l53AyWMX5M23gd3fqnG62LuHu6i72PgOPK4EnAfMxLx711cRdPdxeR39zvcQ4AAAD/BF9b2tbrxI/67r7UcTmf9uPxcRy9+mfArl+LWfT6vZ1AoHuRHxB8mjI4bkf7220YAAAAr/F1QdKvRczqu4e89i/m8G/0o9OL2XR2oERpFQ+XZzGYRMxG53G2KQ2qfr4thWuO6qmeu3lIo32K5y4f4n9uzuJ8VFypk0H5+uODUvZLVRvLTSVt56Piep/EID13cCG75UvrETBpZM16mZsRNieWV76vfv3uvtXLf6jL605tQ/M1B0Y+7Y7Oqd8zr9vs2XpPbVPT87av9nbveO1s926bV+1z7LjvSW24t46beXN52/elY3D4HDixbfXyH+rjd/PfB0aQ7bTt3rKOthMAAPDVvnZE0mwU54c6IUCWFLjet6vraLeUqRUXd09xP4zojR/jaV02tprFop8epxKzxxj3JnG7lzRMphHj9PzdRfzH9VM8jnsRw/vyPdfPatKSFEAMYlmupyqvexwvY7AOKrrX8VSOLKxLWQ8v5LnJIKb9anlPxY7MRqMq3DiyvM0oxuY27HyuzGK06FfLO7oNOa/ZV7zntm6zuk036109xGjU3pbw3vernx/RbPtWGa6cF23QOF7LwSbImd802/wxrtrpp0eOe4bJYBr9ejvvh8U+jarj1z14DpzetlLx+b6oj9/1f/aiX7TLtPH8/M9RsbM/qzLHjPMSAAD4Hr4uSEqdwbLTsO2ECJPg9VJHP11D/emJEShrrYu43iQLrbIsbrb4VT+uDK9eORJwPo1JbxzjRmLRuriK4Wwas9/JAob32+Cq+zPGvVnsbWrDqhyZ1dz2chsm08bIll6Mf74UDuW8Zl/xnvF6va24uBpGLLfzVBUPYrl+0O0+nx+qYaftV7OYzoZx1TheadmTRhqzPXatYtHb9n+L4f127qruz3H0Zos43twvb1sU58S2Katzbfv8PKaTFC7V7884LwEAgO/ha0ckbRSdkHHRcdnp9AH5qpEoT/ftGJ2fLgtqlouVJUu/abVcRrTbxRY0/YjOyeDnvf2KRVl9td23aqL+RojzFdIk4o/9mJ5X2/SqrLws/63L99a3VLNWh1QpQLyPqtzs07+B7YVtO2Qn2Evh4/BqZ7TUe5+XAADAx/gmQVLtxOTbQIZuP4YnwpPUWb/trEuI6pKl39Rqt48ECL3ofNoFnYKrXv2tcM3bK74J7qOU30iXtuU+YvCKMOlHJ3q98c438pW3xtxx1Wi04jj2p3H+mWFSxrY9143+sCpvm08nMexvx2Z9xHkJAAB8jC8LklYPD41RE6t4GI0i9r59CjhtfrM3+iiN9Dj67WirlPdEe/NkVQ7221J4NRvFqFFTt3ooHkc/1pVLHy+VQ8VmXp930yrasmjRTUVWOefRK9psftMIjlLYVd/N0eoVLbjbrlvFZ+bNdl/LMO8zndy247r9VP52E9PJMLY50gedlwAAwIf4whFJ00ZZRDVp692XDx2Av5cfneVeeVHE/dPuXDex+faueh6bTfnXKBbtl5ONqiTp1Le2deP66T7a5XqqZZeTXn/kty62LuJquPutbc2Jx9fb8fvzrhX7dt9os1HE1WtGy/zoxHLT3tXnXPYc3kXrXdzttmu6VbvUinY09jUd9+ZIpZ3jXv/wNzw/B05t2wkpdJxMYrmeZLv0tvMSAAD4Gn/8Vajvv6vFYlH+t9PplP8F3iZdS64jAAAAjvnMDOZ7zZEEAAAAwLclSAIAAAAgiyAJAAAAgCyCJAAAAACyCJIAAAAAyCJIAgAAACCLIAkAAACALIIkAAAAALIIkgAAAADIIkgCAAAAIIsgCQAAAIAsgiQAAAAAsgiSAAAAAMgiSAIAAAAgiyAJAAAAgCyCJAAAAACyCJIAAAAAyCJIAgAAACCLIAkAAACALIIkAAAAALIIkgAAAADI8sdfhfr+u1osFvU9AAAAAD5ap9Op732cDw+SPmMn4J8sXUuuIwAAAI75zAxGaRsAAAAAWQRJAAAAAGQRJAEAAACQRZAEAAAAQBZBEgAAAABZBEkAAAAAZBEkAQAAAJBFkAQAAABAFkESAAAAAFkESQAAAABkESQBAAAAkEWQBAAAAEAWQRIAAAAAWQRJAAAAAGQRJAEAAACQRZAEAAAAQBZBEgAAAABZBEkAAAAAZBEkAQAAAJBFkAQAAABAFkESAAAAAFkESQAAAABkESQBAAAAkOXLg6T5zVmcndW3m3n906Z53JzdFP8PnFJeS5cPsaof89nSZ9VZHPwYq5XH6NQL/tFS+1zGQ84JunqIy7KdivccOqfnN8W/GZnLOmjvWKXlvde1k5ZVLngVD5eHz4d0Hly+ZuPXy0zt4hoHAOCLfWGQVP2SPYj7eHp6qm7X3fq5yurhsugsDGJSPwaOKDqYt8thDGMas79pL7O83g/1uv82unFdfI5tP8aeByfd6+efc9/fKwKgd7KaTSM6P4pVT2PZ70Wr/nml+LfjdhnDYcT0zSf7/rF6L2nbJjHsv++CV8tif4tllu3yrD0AAOBzfV2QNP8zRjGOxyO/yadO5fm0H4+P4+jVPwMOqzqYP+NnP2L05985jIFVVHlJK+bTSbTbe7HJahbT6MfP6mSPb3W2l9s2jp/vmiOl9mhHyqZ+Lap2AQCAr/RlQVLqIAyvLo7+ZbV1cRdPd8efB9a2He9Wrx+9yXSvc12PKJk/xOW6jHSvXLQa/bf73H75TfmaZlnNfjlQWW60XkZzBEtd4vNQr/9AaU5a1/loFjEZlO/fDkyqSpD2t+2kne1oLqvaju1zz0fZ7LRD8cbdNnipHev9TD9IJUjlaMpZjM6L19X7vB111Xjtxv7Pdvf9xVKoo/t9ug3X21SW3dWv2azr5H481O25bced9msu55lqXw8/34qLu7u4KD780wiu/b81bEbltHrFfyYxPdSGO+faiZ/tvLfQbMP983SvfQ9t+9tGDNXn1ap5nJrnZmqP60jN0L2u2gUAAL7SFwVJq1gue9GJZofseacOyFCP0CgHKhzsXCezGN1GjMsy0scYF68ZrHvRq4cYjdpxvy4xve+XP+72hzGbzurOdAqrZsVitqVzqdymt+40p072IBrLaBfL3O2IT4o+drn+AwFxCgwex72IYVXqWoUHqWM9iOX4sVpmcXscL2Ow38Fv2t+Ox3HxOZOk4OA8Ru1GKW3axvNtqJJCkHIU5Pr5/jQGz+pqT7RjU+si7p7uYxi9GD8Wr322z62y7SbNA1WP0qxGs1T7XuxIvb330R6Njn9GHt3vzDacDGLar997Xxz39bpO7Ud1QIv3VOFG2X7N86jc5vPnYc1v2YamB9uwduhcO3X+lWaj8viv2+m+XTxubPy8eP/2/E5ttD8aah5/jt46YigFdcVVvFn+7rkJAADfyRfOkdTskPnFGd5qXvVe687xsc51L8bjdQe6FRdXw4jlshEmLGO5ftDtlqMfotuP4WwRv8of/opFjGM8nMWi/EGzQ5862ZPojX9W70u6P4tX787XdGoE4kFFz33SK9bZGILRurgqtunYPFCran6a+2r0Rql1ERfpQQrbZsO4bw5vSdu4Cd2qoGxnG7vXcV80066X2jHf/uixsg03wVy179sSqW78HB+bE+jEfue24fB+O/KnbJf1cT5heNUYHVO3X3Mbym0+HPSUbXf3FHevHV5Thm11aFo4PALv8Ln24vlXtFOz1LpbNHhz2d3rxr6la6N5zSSprXfa5DVSUNdcfvPcBACA7+ULg6S9X+z94gxvMI/pJA2mOK9H9q1LxG7zR/ilUSeP/Zim0qXi/dtBGD+is74mi05ymvT4oj+sgoHmKKhIIwx3t+Hs7DxGs4ww4oQ04ina7b3Of9qmY8v9FYtZr5yj+Zlfi5j1OsW7m1pp8cW2p4Y68d6PUrT71XD9mZeO4zCu6hSi3Pc0QmbTntVxnR3c8ePb/vo2fKvD29CqGvhNQdshKWzbaZfzUcxiErcfMZy11Y5i67fKMr/18Xj+JRBlufYrJtl+NvfTjurcBACA7+iLgiS/JMO7qEecbMqx6tv9MI3AeUXnuixhSu+9jxisw6Tt6Kb5dFmNPkojMdIojRTMbAKK6noebsqwtrf9+W1e43gIcSzwORGQ/OhEbzO6ate2Q7//3iog+0ipfLAM5srRLP3NiJRy3+syv53bwQY9vt+vb8O3OtH2m/Pkd6WwrS6xa7ZJKjPblGC+o9UyNoc/hUjni7jarDeV+zUUz99OhuWE2FvNoLIp57z6+HMPAADe6stGJJUdqEGjlC2VLMz2fxEHTtkph2rYnd/oBfObvVFI9d1CWTq0vI3b5Xr0UTf6w2Xc7n3F+bPr+T2UpXWjGDVGm6weiseN0qZddfDV3I6ig/+QHtRzR+3MZ1Ts92DT+U/7lQZyNeYOKj+T6vsfpQ7mbvZHs5Q/H2TOL3Riv1/dhm91YBuKezeDY6N0qsmuX5xAvKkMTQ9sd7mPx8odX6Fop+0XHhbbNxpFrMs190e0pW2p7yblJNvN0s5aeR3uzW1Vtf/+N7vNdr5t8fBrAADge/i60rbudVSDH+pSgXKi2Ob8GsBJ5SiIFJAcSATqAKHRNz3uRyeWg3XJznlM+4/bkUQpgCk6uds5mMqXx2w/9C2u53IS503pT3E7NSn2AeXcPTvf2taN63rC5vUyy8mwj02WXEjf9rizHedFB7/s/ac5eR5jvKyWX972PnO618XzRfd9UzZVrOv5HEmvUc1r1Py2s+dSgDWJyXI/NCj2/XHcOC7pdvwLCY7v9+vb8Lmc/TiwDVUD/9aotK1qHqhDoWnVhrtBzJv0xtGZrre9mph9M4dTOedX89yIxoik3fnCdpT/zqX5/9bLPdb+vRh3ptvXpEnLX3WMAADg8/zxV6G+/64Wi0X5306n+u4g4G3SteQ6+gpp1Mx5LK7eKwzhHyl9Y95t55XhXFP6Zr3b6Dz6an8AAN7uMzOYL51sG+C7KsuLlNvygnKS7dd+IyEAAPyNCZIACquHy01p0aa8SLktL+heG7EGAMC/i9I2+OaUtgEAAHCK0jYAAAAAvh1BEgAAAABZBEkAAAAAZBEkAQAAAJBFkAQAAABAFkESAAAAAFkESQAAAABkESQBAAAAkEWQBAAAAEAWQRIAAAAAWQRJAAAAAGQRJAEAAACQRZAEAAAAQBZBEgAAAABZBEkAAAAAZBEkAQAAAJBFkAQAAABAFkESAAAAAFkESQAAAABk+eOvQn3/XS0Wi/oeAAAAAB+t0+nU9z7OhwdJn7ET8E+WriXXEQAAAMd8ZgajtA0AAACALIIkAAAAALIIkgAAAADIIkgCAAAAIIsgCQAAAIAsgiQAAAAAsgiSAAAAAMgiSAIAAAAgiyAJAAAAgCyCJAAAAACyCJIAAAAAyCJIAgAAACCLIAkAAACALIIkAAAAALIIkgAAAADIIkgCAAAAIIsgCQAAAIAsgiQAAAAAsgiSAAAAAMgiSAIAAAAgiyAJAAAAgCyCJAAAAACyfHmQNL85i7Oz+nYzr39amN9sf17cmk8Bz5XX0uVDrOrHfLZ53LzwWVUeo3/th1lqn8t4yDlBVw9xWbZT8Z5D53T578OhZa3i4fI3/r1I683dxmfSuuv37v37Vd3eutx3kvatbMt0HG6K/wcAgLf5wiCp+oV/EPfx9PRU3a672+emnXhc//xxHMvBF/8SDt9Z0Um8XQ5jGNOY/U2vk9XD5d88ZOnGdfF5tfkYOxCcdK+bn3N/F68IgN7JajaN6PwoVj2NZb8XrfrnleLfh9tlDIcR0/c+2VsXcfd0Fxe7K8wz/zNG0Y/e+r298fbfsHS7b8fo/Cwuv+ofsl+LiNSWRZtOhv3ibAUAgLf5uiCp/KW7+EX7YKeqFRfXF9vOQ/HL/dVw9v6dBviHKDve/Z/xsx8x+tNYA/7OVlGezr1WzKeTaLf3Up1V8W9B9ONndbJ/m5E1aVuHV41/t/Z1r8s/inzVNs+ny7JNV8tlDPtiJAAA3u7LgqQXf+nesYrid9/nHQqgsO14t3r96E2mex3VekTJPJXtrMtsdktbytFAe8+lMqzm6InyNc0yo1S+s/94s4zmCJa63OihXv+BUqW0rvPRLGIyKN+/HZiUtn29zHTLKMk5WhZbbcf2ueejbHbaoXjjbhu81I71fqYflCVSg5jErByFst7n7airxms39n+2u+8vjmQ5ut+n23C9TWXZXf2azbpO7sdD3Z7bdtxpv+Zynqn29fDzrbi4q0YFpRFc+39rqELTXrRaveI/k5jutOHa7rE+1M7b7Wy2R32MG5uVt0/zmE6G8WI+c2ib98vgNhv7/BzZL43cnk/b+wePY6F7XbVp6+LuWZsCAMBrfFGQlIKhXnSi2SF73qnbSKOXZhm/pMO/UT1CoyypOdq5nsXoNmJcltk8xrh4zWDdIV09xGjUjvtNCU6//HG3P4zZdFZcrUkKq2bFYralc2lkQ29ddpQ6w4NoLKNdLHM3MJoU/f9y/XfPA+QUGDyOexHDqtS16uimTv0gluPHapnF7XG8jMGBIGpjfzsex8XnTJI65ecxajdKactSo22IkDri59P+thypP43BpH5y40Q7NpUlUvcxjF6MH4vXPtvnVtl2k+aBqkdp/mzse7Ej9fbeR3s0OvEZeWy/M9twMohpv37vfXHc1+s6tR/VAS3eUwUUZfs1z6Nym8/3QpzftQ1ND7ZhbTIY1dtW3PZLo4vrZdFft0d1DG+PNGzuPq0ebjPLxVrRbkfx71+9vvK4Lau2XW/PclAHQPv7l8Kq4j+NoPjXYrY7uujYcQQAgHf0hXMkNTtk6Zfe3U7dxuYX7WtzOsAB8z+LTvM60Dnaue7FeLwOAVpxcTVMvdlGmLCMdd82ut3qWuv2YzhbxK/yh79iEeMYD4tOePmDZoe+2Iaih9sb/9xeo92fxat352vKH4FYS3O59Ip1NiasaV1cFdt0bB6oVTzcTmJ43/isaF3ERXqQwrbZMO6bQzHSNm5Ctyoo29nG7nUUffE9L7Vjvv3RY2Ubro9jve9VqJR04+f42JxAJ/Y7tw2H99tRKmW7rI/zCcOrxlxCdfs1t6Hc5sNBT9l2d09x19iuLHvzEB0egZd2pzHP0X5pdPH4evtk2eazgzubu0/VtTDeHqxs1XUzbrRjdU6tA9xy/9bn16q4RofFseytr9UDo6DechwBAOCVvjBI2utY7nTqKuUQ/ds06fYbJz+Ff7xqlMJsdL4pZ6lKxG7zRyKkUSeP/Zim0qXi/dvRFj+is74m60mPL/rDqhPdHAVVdHNT6WlzG87OzmM0+71ObBrxlIZv7F76aZuOLfdXLGa9co7mZ34tYtbrFO9uao4OOfHej1IGHOvPvCoUuKo/6Mp9n43ifNOe1XE9HHgc3/bXt+FbHd6GVtXAVRDyDlLwstMu56OYxfERRWs/Or36XqVZ/lVeLwdl7tPOtfCSZpn2kZLtH53orQPcVjvadeiXSvra/Yvo9etA0aTZAAB8kS8KkqoO3CnpF/3bzuPBMhigVo842fl2qOJ2/9rJ6VOYVL73PmKwDpO2o5vWE/WWo5TSCJAUzGwCiup6Hm7KsLa335mL5XgIcSzwORGQNDvne7Yd+f33Vh39j5TKB8tgbi8UKPe9LvPbuR1s0OP7/fo2fKsTbb85T35XCtvqErtmm6QSrnoEzzGpBGxt829L/f6ypPKgvH3aHRH4gp3yxb0yt6ZN6NmNfnktz4t9bJejj9IopeIHMS+Oa+99DyIAAGT5shFJZQdq0Chla86DlL7KvPHXeeCwnXKoht35jV4wv9kbhVTfLVSlNbdxu1yPuEgd22XcplKqRk3Ns+v5PZSldaMYNUabrB6Kx0dHf9TBV3M7is+Sh/SgnjtqZz6jYr8Hm9KgtF9pIFdj7qDyM6m+/1HqYO6mOI47c92UPx9kzi90Yr9f3YZvdWAbins3g7392qgmkj4+GfcBZWh6YLvLfdwt1ds9jtVxrv492R8FVJWvHZazT7sjyU4pJ8NOZdqb0si06fvzGBXtUjxuBlPVtXwb03YdNKZzOaZx2ygtBQCAz/R1pW3pq5DLwQ91iUE5UWxzLoqi07d+bn07Ncku/NuUgWsKSA50JusA4c+cIOJHJ5aD9XV2HtP+43YkUdlpLTrajY5t8fKY7U9+X1zP5STOv3G9lnP37HxrWzeu68mN18ssJ8M+MUoxfSPVznacF73tctBGmpOnmsh4vaz9z5zudfF8NMqminU9nyPpNap5jZrfdvZcCrAmMVk250NKin0vJ4mut6W8Hf9CguP7/fo2fC5nPw5sQz1Z+O+MStuq5oE6FJpWbTiLUeNkH/aL7V1vx84ce9UcRJNNu45i0T42Iiljn06Vl+2XJi6uYj0x+Ub572CaH3D9uur625k7qryWZ9HeXHBpJNOsuCrfOwwEAIA8f/xVqO+/q8ViUf6306m+Owh4m3QtuY6+Qho1cx6Lq/cKQ/j2Vg9xeb6Iq50/ahzj/AAA4Pv4zAzmSyfbBviuyhKw/ZFX/KOlCa1nuRNYl5Ns748kAwCAfz5BEkChnMOmWYo0au+V2/JPtT725THPHV6UJqj3ZRAAAPwLKW2Db05pGwAAAKcobQMAAADg2xEkAQAAAJBFkAQAAABAFkESAAAAAFkESQAAAABkESQBAAAAkEWQBAAAAEAWQRIAAAAAWQRJAAAAAGQRJAEAAACQRZAEAAAAQBZBEgAAAABZBEkAAAAAZBEkAQAAAJBFkAQAAABAFkESAAAAAFkESQAAAABkESQBAAAAkEWQBAAAAECWP/4q1Pff1WKxqO8BAAAA8NE6nU597+N8eJD0GTsB/2TpWnIdAQAAcMxnZjBK2wAAAADIIkgCAAAAIIsgCQAAAIAsgiQAAAAAsgiSAAAAAMgiSAIAAAAgiyAJAAAAgCyCJAAAAACyCJIAAAAAyCJIAgAAACCLIAkAAACALIIkAAAAALIIkgAAAADIIkgCAAAAIIsgCQAAAIAsgiQAAAAAsgiSAAAAAMgiSAIAAAAgiyAJAAAAgCyCJAAAAACyCJIAAAAAyCJIAgAAACDLlwdJ85uzODurbzfz+qcRq4fL7c+LW+Mp4IDyWrp8iFX9mM82j5sXPqvKY/Sv/TBL7XMZDzkn6OohLst2Kt6zOadX8XC5/Tdhc/vK9pzfvNs1l86NclfSvr+wj689j8p/T1/bTmnf0nvS9vhcAQCg4QuDpKpTMIj7eHp6qm7X3c1zs0U/Htc/vx/GZHBTdCmAg4rO3u1yGMOYxuxv2uN7U2f3W+nGdfF5tfkYOxCcdK+bn3N/F68IgN7JajaN6PwoVj2NZb8XrfrnyfC+/nehvD3GeDmIs7O/+b8P6fqdDKO/OTWGcb/Zx/sYTgZx2TgA734eleHVbhuulssYFhtUHou9YwAAwL/b1wVJ8z9jFON4PPjLcCsuri+2v7h2+8Wv1ctY+pMoHFR19n7Gz37E6E+RK39nq6iyi1bMp5Not09FGMW/FXdPcT+cxO1nJl3vrLx+xz/jcDTUjZ/jXswWv+rHnyEdg3YZbP1aVMcCAADWvixISh2E4VUjLDph9XAbk+FVXPhdFg7YdrxbvX70JtO90Rn1iJJ5s2Rmb/TBTilp9Vwqn2mOgihf0yxx2S/rSY83y2iOYKlGH9481Os/UCaT1nU+mkVM0uiSZnlY2vb1MtMtY+TJznY0l7VfGvV8lM1OOxRv3G2Dl9qx3s/0g3KExyAmMYvRefG6ep+3o64ar93Y/9nuvjePxUFH9/t0G663qSyXql+zWdfJ/Xio23Pbjjvt11zOM9W+Hn4+hUN35ed9GnmTM/Cm2x8W18Cs3LbK8bbL2/bn51mzffaf/9V87+5BfdYme08Xttdvrmofmgtq7u/6HD29D5s2SefN+ag4wpMYpOfK5aZjcF0GW93r6lgAAMDaFwVJq1gue9GJZodsr1NXdmCq59LIpb9fOQh8ktUsptGPsh/a6hUd0klMn3VWZzG6jRivy4GK1wzWHdHiWhuN2ttSmvt++ePdznnq7M6KxWxL51LpS29d8pI6o4NoLKNdLHM3MJqkQRfpubvnAXIKDB7HvVS3VL6/utxT53gQy/Fjtczi9jhexuBAELWxvx2P4+JzJknBxXmM2o1S2rSN59vOduqcn08bJbX9aQwm9ZMbJ9qxqXURd6kkKXoxfixe+2yfW2XbTZoHqh6l+bOx78WO1Nt7H+3R6FnwtXF0vzPbcDKIab9+731x3NfrOrUf1QEt3lMFDWX7Nc+jcpvPDwQnH+BHJ3qzRVRjdjLa7tC2N4592UaNDU8BTLMM+3FctW5pNorb9G9Ueq5o917Rltu3FtdNo0w7neOT2722L497ff0eUl6fxeZWJ8YB+/s7jrhNwdCeY8e4e11t97qczr+1AAC84AvnSGp2yNIvtruduqoDUz03Ln7NzhqJAP9C8z+LXuZmDpMDAUWpF+PxOgRoxcXVMGK5bHRoG6Wj3W5VYpNKSjed81+xKK7E8XAWVYXN7iiKNMKw1yzN6f4sXr07X1PuCMSN+TQmvWKdjeEQrYurYpuOzQO1iofbSQzvq5EUpeJz5CI9SGHbrOgoNzvJaRs3oVsVlO1sY9HBLvrbe15qx3z7o8fKNtwEc9W+b7ODVN4UxT4cWtOJ/c5tw+H9duRP2S7r43zCzijRuv2a21Bu86FzMalK0u4a2/Vuctru0LY3jn3ZRutjs6rmL2qeO62Li+1+Ntu3aPfqlFivq9jPRpl2ecw311Tl8OjcenRQuqUQqQ68Dnq2v8U6xykY2vOWYwwAAAd8YZC017Hc6dTtal3c/e3nwICPMY+iHxqz0Xk9sm9dInZ7fPTKvhTaPvZjmkqXivdvR1P8iM76miw6q2nS44v+sAoGmqOgio74crm7DWdn5zGa/V5HNY14inZ7r4OdtunYcn/FYtYr52h+5tciZr1O8e6mVlp83ek/8d6PUoYO68+8dByHcVWnBeW+z0ZxvmnP6rgenifn+La/vg3f6vA2tKoGflPQ9iqN4/u6tkvStqcBO9vXn52lcr46XD147rxCs+SwLCFrqo77dpLttfVk24/lH1JGJy7mw8cYAAA+zhcFSVUHDvhN9WiETTlWfbsfphE4r+i+pzCpfO99RNGhrsKk7eim+XRZjT5Ko5TSSI3Uud50XqvreffbtKrb71TJHA8hjgU+JwKSndKnXdvJnPffWwVkHymVD5bBXDqOw/5mlEu573WZ387tYIMe3+/Xt+FbnWj7zXnyUeoRWfUfJl7Xdkna9rp0b+c99SigE+fOi1KIdNvZXp9lCdlWNf/f9rg/V40uSrVtJ4Ph/WOcrs/6LgAAvLcvG5FUdqCaX+mf5omY1X+ZXT3ETfO35uKX8cEkzf3ysd0R+LvZKYdqeD758AnF9bU7Cqm+WyhLcZa3cbtcjz7qRn+4jNvUcW8Mo3h2Pb+HsrRudzTG6qF4fHQ+mTr4am5H8VnykB7Uc0ftzGdUfq6sR4Ok/UoDuRrz15SfSfX9j1IHczepvKk5LKX8eXOunVNO7Per2/CtDmxDce9msLdfG6cm236NND9QNffVtmzrNW2XpG1PWc2RubcOnDurh4fGfh63P1oofTvb9pSqykOPz31Ua11ElSUd3r6qXG4U2y9rrII1AAD4KF9X2pYm+CwHP9RD/su5Quv5NVrt4rfmRpnMYBnjR98cAzvKuVuOBKx1gLDtXJ7woxPLTVnPeUz7j9tOeepEp65vI6wqXh6zdei7VlzP5QTF62s23U5Nin1ANS9N81vbunFdT9i8XmY5IfKBybrXUhnsznacFz31cuRNmpPnMcbLavnlrfmZU+heV2VEm5KoYl3P50h6jWpunua3nT2XAqxJTJbNOW6SYt8fx43jkm57X0jQcHy/X9+Gz+Xsx4FtqCeA/p1RaYfslqDdRieNJNpZyevaLinLp9u75XDbb0V7fu5smvcFzXM63UaL9nZE0k556Gmti3F1bh5Kx9JowuJE3bbLKOLqwBxJp9RlluWxy0/gAAD4l/rjr0J9/10tFovyv51O49ttgFdL15Lr6CukUTPnsbh6/zAE0jfB3XYeP2jC8bqk7lWBIQAAf2efmcF86WTbAN9VWQK2P/IK3sXu5OrvqyopPFTyCgAA78GIJPjmjEj6HKuHy+ob7zbSN2c1v84evqM0T1T6lrmt3viDRjoBAPBtfWYGI0iCb06QBAAAwCmfmcEobQMAAAAgiyAJAAAAgCyCJAAAAACyCJIAAAAAyCJIAgAAACCLIAkAAACALIIkAAAAALIIkgAAAADIIkgCAAAAIIsgCQAAAIAsgiQAAAAAsgiSAAAAAMgiSAIAAAAgiyAJAAAAgCyCJAAAAACyCJIAAAAAyCJIAgAAACCLIAkAAACALIIkAAAAALL88Vehvv+uFotFfQ8AAACAj9bpdOp7H+fDg6TP2An4J0vXkusIAACAYz4zg1HaBgAAAEAWQRIAAAAAWQRJAAAAAGQRJAEAAACQRZAEAAAAQBZBEgAAAABZBEkAAAAAZBEkAQAAAJBFkAQAAABAFkESAAAAAFkESQAAAABkESQBAAAAkEWQBAAAAEAWQRIAAAAAWQRJAAAAAGQRJAEAAACQRZAEAAAAQBZBEgAAAABZBEkAAAAAZBEkAQAAAJBFkAQAAABAFkESAAAAAFkESQAAAABk+fIgaX5zFmdn9e1mXv90V/may4dY1Y+B51wnX20eN8Xn2JGPsVJ5jE694B8ttc9lPOScoKuHuCzbqXjP5pxexcPl6fZ9N2n9uduaq1zmTbFHr5Tet26D+c3br/Fy/enf2mP7ldq3ei6dp//a0xQAgBd9YZBUdQoGcR9PT0/V7bpbP9dQ/PJ7O6nvA4el62Q5jGFMY/aend9PtHq4/JuHLN24Lj7Hth9jz4OT7vWRz7lv7RUB0DtZzaYRnR/Fqqex7PeiVf/807Qu4u7pLi4+fcXPzf8cRfx2GxT/3o5G0b5P/9ZW+/X8evsVi+hHrzWP6WQY/b/baQoAwKf5uiBp/meMYhyPL3Sq0i/R7eGwfgQcUna8+z/jZz9i9KehBPydraI8nXutmE8n0W5/gzTny1ShztVvJ1q/YjHrldncUevQbrWM5bAfciQAAI75siApdRCGVxen/8o6v4nBclx2joFjth3vVq8fvcl0r3ymHlEyX5e2pNtuiU05OmHvuVTectkYhlK+pllWs19mkx5vltEcwVKXJD3U6z9QmpPWdT6aRUwG5fu3AyXStq+XmW4ZpUE729FcVrUd2+eej7LZaYfijbtt8FI71vuZflCWEQ1iErMYnRevq/d5Owqk8dqN/Z/t7nvzWBx0dL9Pt+F6m8qyu/o1m3Wd3I+Huj237bjTfs3lPFPt6+HnW3FxV42aSSO4Dv+tYf9YVrftPu8+f1mce81RVdvjsHao7XfPj919a7Zh/dqHuv03C9lt95vi9N61d1wOXBcp3Jlkhzp7bbLejgPH8H8OXW/d67hLjZ5GY/3tRs0BAPCZvihIWsVy2YtONDtku7+0l79kD5YxHr8QNsG/3WoW07Ikpbjf6kW/N4nptpdbKzqRtxHjsoz0McbFawaNjuZo1I77dYnpfZXcdvvDmE1ndec2hVVFx3O2LZ1bLZfRW5fcpBBjEI1ltItl7naMJ9N6/XfPr+kUGDyOexHDqtS16semjvYgluPHapnF7XG8jMGhDvfa/nY8jovPmSR1ss9j1G6U0qZtPN8GAikoOJ/243H9fH8ag2dltSfasaksjbqPYfRi/Fi89tk+t8q2mzQPVD1K82dj34sdqbf3Ptqj0bPga+Pofme24WQQ03793vviuK/XdWo/qgNavGdbKnXePI/KbT5vhDPvKYVN6/Vsz53qvKmO9bS/3eerxSh+p0J6/9wo23Bnx4rzYtGv1lduxP7xe4zOdFS8qmFetF/j+A5no9gdTFjsx+0khlk1Zvv7XJyby0HV9geO4X8cvN4AACDPF86R1OyQFbe9Tt38JnV+xt9ijgr4znbnUDkQUJSKTuQmlC064VfDiOWyESYsY7l+0O1WIyC6/aJzu4hf5Q/T/CnjGA9nsSh/sB0FlaQRhr3xz+3Iie7P4tW78zW9OAJxXxqN0SvW2fgQaF1cFdt0bB6ouuN9f73djqITfZEepLBtNoz7Zo85beMmdKuCsp1t7F7H/bOq2pfaMd/+6LGyDTfBXLXvVaiUdOPnOIp9OLSmE/ud24abEKZQtsv6OJ8wvGp8Ptft19yGcpsPnYtJFQSVI2B+1zoIXe9Afayb5WDd6xSkvNXzc6Nsw52Rf8V5sT1YB45fsb/Fv2e9+lGpOL+2p2M3+uWp1DgoZUDcXMYJz/a5OjcPtz0AAPyeLwyS9jqWjU5d+utvKmlrdn6AQ9IcKhGz0fmmpKUqWbk9PnplXxqx8NiPaSp7WZe5lH5EZx20FB3jNH/KRdHbLTunzVFQRUd7udzdhrOz8xjNMsKIE9KIp2i3t58RpbRNx5Z7Yh6YX4uY9TrFu5taafF15z1jDpn3VrT71XAdZO3OhVPu+2wU55v2rI7r7OCOH9/217fhWx3ehlbVwG8K2vLM4+a8OBMfGwHWwWP9O9K+pUFb22NxdpZKxRrh657D7b4vjSLaLnN/9Fs171nmJNtpn4stGmy2r7ilBX5o2wMA8G/1RUFS1YE7bF1C0+hEpV+Iy8f75W/wL1ePfNiUY9W3+2EaofCKi6Usf0nvvY+iN1qHSdvRTfPpshp9lEYppZEYqeO66ShX1/NwU6azvf1OyczxEOJY4HMiIPnRid5mdNWu7WTO+++tArKPlMoHy2AuHcfGXDjlvtdlRzu3gw16fL9f34ZvdaLtN+fJ+zs4cvXQsU4TSNd3Xy/tW10WtnM8jn+r28F2L8OetaoUbXG1Xd7u6Ld5VAMNM1su7fOBz4FDZaQAAPC7vmxEUtmBGjQmLE3zg8zSVw5XJQ87vwyn37DLX5K/x9cxw3exUw7VsDu/0QvmN3ujkOq7hbL8ankbt8v16KNUgrOM2725W55dz++hLK0bxaiRHq8eisebkVD76uCruR2rh3hID+q5o3bmtSn2e7D5mvOqtGhy25g7qPxMqu9/lDqYu0lfPtCcC6f8eT3HzYtO7Per2/CtDmxDce9mcGyOn2o0zosTiJ9wdORqqx3tmMRtY9mp/LN5KMugp1GaVrbJ0WOd9i2ezfl1UhlmNec8qsoPt/ZHcFUjCzfKYLFZOviCdH4XR7V5nAEA4KN8XWlb9zqqwQ/rUUdp3tHm/BrASauHuJ2kgORAb7MOEHYn7z2i6PQuN2U71YS9m4EvZQe16GE3wqri5TErQ9/6B0lxPZcTEK+v53Q7NSn2AdW8M81vbevGdT1h83qZ5YTHJ0ZZtC7udrfjfJqysfRMXNxVExCvl7X/mdO9Lp4vOuObkZDFup7PkfQa1bxGzW87ey4FWJOYpG+n3PnwK/b9cdw4Lul2fETm8f1+fRs+l7MfB7ahnmz6d0alHVXOi1Scl+VI1fX61sHU832e9vfmSCrnv9qWgo3iKtLc08ekfbtv765r91vf9pTlos3jN4q4as6R1GjT8vnieDU2sPxW04MBXGFvn6tjks7v3X1Ot9ObuH+9AQBAnj/+KtT339VisSj/2+lU3x0EvE26llxHX2FbfvQhYQifKH2L2m10Hv8Go1pXD3F5vogrf1gBAOAVPjOD+dLJtgG+q6rcaW/kFXywcpLt5jcgAgDANyNIAiikOXeaZUHn6SvljQrhk6UyujuTAQIA8I0pbYNvTmkbAAAApyhtAwAAAODbESQBAAAAkEWQBAAAAEAWQRIAAAAAWQRJAAAAAGQRJAEAAACQRZAEAAAAQBZBEgAAAABZBEkAAAAAZBEkAQAAAJBFkAQAAABAFkESAAAAAFkESQAAAABkESQBAAAAkEWQBAAAAEAWQRIAAAAAWQRJAAAAAGQRJAEAAACQ5Y+/CvX9d7VYLOp7AAAAAHy0TqdT3/s4RiQBAAAAkOXDRiQBAAAA8M9iRBIAAAAAWQRJAAAAAGQRJAEAAACQRZAEAAAAQBZBEgAAAABZBEkAAAAAZBEkAQAAAJBFkAQAAABAFkESAAAAAFkESQAAAABkESQBAAAAkEWQBAAAAEAWQRIAAAAAWQRJAAAAAGQRJAEAAACQRZAEAAAAQBZBEgAAAABZBEkAAAAAZBEkAQAAAJBFkAQAAABAhoj/H4sMsGITqArAAAAAAElFTkSuQmCC)
"""

if (N_S == 10 and N_B==1):
    events = mne.find_events(rawdata, initial_event = True, consecutive = True,min_duration = 0.002)
    # The different load of the events delet the spureos trigger but also the Baseline finish mark
else:
    events = mne.find_events(rawdata, initial_event=True, consecutive=True)

"""# **Check Baseline Events**
A spurious event, of unknown origin, with ID 65536 appeared at the beginning of the recording and also it randomly appeared within some sessions. This event has no correlation with any sent tag.

The raw events are stored in a three column matrix, where the first column contains the time stamp information, the second has the trigger information, and the third column contains the event ID.

In simpler terms, a "baseline event" in EEG data is like setting a starting point before something happens. Imagine you're measuring brain activity while someone watches flashing lights. Before the lights start flashing, you have a period where the brain is just doing its normal thing, not responding to anything special. This period is the "baseline event." It's like a reference point that helps you see how the brain's activity changes when the lights start flashing. By comparing brain activity during and after the baseline event, you can understand how the brain responds to different situations.
"""

def Check_Baseline_tags(events):
    # The "raw" events should star as [65536,11,13,14,15....]
    # The event 65536 is deleted later in the Events_Correction

    # The tag 14 (end of baseline) should be in the 4 row in the 3 column
    if events[3,2]!=14:
        # Add Baseline event
        # The baseline duration is 15 seconds, (sf=1024)
        # Add the event 15 seconds after the start Baseline cue
        time = events[2,0]+15*1024
        correction=[time,0,14]
        events= np.vstack([events,correction])
        events = events[events[:,0].argsort()]

    return events

events = Check_Baseline_tags(events)
print(events)

"""# **Check and Correct event**
Extra events removed in this step such as event with ID 65536
"""

events=mne.pick_events(events, exclude=65536)

print(events)

"""## Initializes a NumPy array Events_code with zeros
The array has a shape of [len(events[:,2]) ,2], indicating the number of rows is the length of the third column (presumably event codes), and there are two columns.

This line assigns the values from the third column of the original events array to the first column of the Events_code array.
It's essentially copying the event codes to the first column of Events_code.
"""

Events_code=np.zeros([len(events[:,2]) ,2],dtype=int)
Events_code[:,0]=events[:,2]
len_Of_Events_Code=len (Events_code)
# events = Event_correction(events)
print("Events_code",Events_code)
print("len_Of_Events_Code",len_Of_Events_Code)

"""## Unique Events
This line assigns the values from the third column of the original events array to the first column of the Events_code array.
It's essentially copying the event codes to the first column of Events_code.
"""

Events_uniques=np.unique(Events_code[:,0]);
print("Events_uniques",Events_uniques)
Event_count=np.zeros([len(Events_uniques),2 ],dtype=int)
Event_count[:,0]= Events_uniques
print("Event_count",Event_count)

"""## Count"""

a=0
for i in Events_uniques:
  Event_count[a,1]= len(np.extract(Events_code==Events_uniques[a], Events_code)  )
  a=a+1
print(a)

"""## CHECK EVENTS
WORKS ONLY IF ARE NOT 2 CONSECUTIVES TAGS MISSING

* for i in range(len(Events_code)):: This loop iterates over the rows of the Events_code array.
* Events_code[i, 1] = i: It assigns the value of i to the second column of the current row in Events_code.
* if Events_code[i, 0] == 42:: Checks if the value in the first column of the current row is equal to 42.
**Nested Conditions:**

If true, it checks if the next event (Events_code[i + 1, 0]) is

* one of the tags 31, 32, 33, or 34.
* If yes, it does nothing (passes).
* If not, it assumes that the tag is missing and tries to identify the missing tag based on the minimum occurrence count of the existing tags (31, 32, 33, 34).
* It prints a warning message, increments the Warnings counter, and appends information about the missing tag and its position to arrays.
"""

Warnings=0
# Warning missing code
Warnings_code=[0]
# Warning positions
Warnings_pos=[0]

for i in range (len (Events_code)):
    Events_code[i,1] = i

    # Check Tags  code = 31 32 33 34
    # Find the star mark
    if Events_code[i,0] == 42:
        # If the next mark is the tag is OK
        if (Events_code [i+1,0]==31 or Events_code [i+1,0]==32 or Events_code [i+1,0]==33 or Events_code [i+1,0]==34):
                # Do nothing
            pass
            # If the next mark is the mark for concentration the tag is missing
        elif Events_code [i+1,0]==44:
            min_tag= min(Event_count[Event_count[:,0]==31,1],Event_count[Event_count[:,0]==32,1],Event_count[Event_count[:,0]==33,1],Event_count[Event_count[:,0]==34,1])
            miss_tag=Event_count[Event_count[:,1]==min_tag,0]
            print('Warnings, miss '+str(miss_tag)+' at i = '+str(i))
            Warnings=Warnings+1
            Warnings_code= np.append(Warnings_code, miss_tag)
            Warnings_pos=np.append(Warnings_pos,i)
    if Events_code[i,0]==46:
        if (Events_code [i+1,0]==42 or Events_code [i+1,0]==16 or Events_code [i+1,0]==17):
            pass
        elif (Events_code [i+1,0]==61 or Events_code[i+1,0]==62 or Events_code[i+1,0]==63 or Events_code[i+1,0]==64):
            print('Warning, miss Question at i = '+str(i))
            Warnings=Warnings+1
            Warnings_code= np.append(Warnings_code, 17)
            Warnings_pos=np.append(Warnings_pos,i)
        else:
            print('Warning, miss start at i = '+str(i))
            Warnings=Warnings+1
            Warnings_code= np.append(Warnings_code, 42)
            Warnings_pos=np.append(Warnings_pos,i)

"""## Full Event Correction Function Code"""

def Event_correction(events):


    # Exclude this tag from the events
    events=mne.pick_events(events, exclude=65536)

    # Counts the events ===================================================
    # Initialize vars
    Events_code=np.zeros([len(events[:,2]) ,2],dtype=int)
    Events_code[:,0]=events[:,2]

    Events_uniques=np.unique(Events_code[:,0]);

    Event_count=np.zeros([len(Events_uniques),2 ],dtype=int)
    Event_count[:,0]= Events_uniques

    # Count
    a=0
    for i in Events_uniques:
       Event_count[a,1]= len(np.extract(Events_code==Events_uniques[a], Events_code)  )
       a=a+1

# CHECK EVETS =========================================================
#         WORKS ONLY IF ARE NOT 2 CONSECUTIVES TAGS MISSING
# =============================================================================
    Warnings=0
    # Warning missing code
    Warnings_code=[0]
    # Warning positions
    Warnings_pos=[0]

    for i in range (len (Events_code)):
        Events_code[i,1] = i

        # Check Tags  code = 31 32 33 34
        # Find the star mark
        if Events_code[i,0] == 42:
            # If the next mark is the tag is OK
            if (Events_code [i+1,0]==31 or Events_code [i+1,0]==32 or Events_code [i+1,0]==33 or Events_code [i+1,0]==34):
                # Do nothing
                pass
            # If the next mark is the mark for concentration the tag is missing
            elif Events_code [i+1,0]==44:
                min_tag= min(Event_count[Event_count[:,0]==31,1],Event_count[Event_count[:,0]==32,1],Event_count[Event_count[:,0]==33,1],Event_count[Event_count[:,0]==34,1])
                miss_tag=Event_count[Event_count[:,1]==min_tag,0]
                print('Warnings, miss '+str(miss_tag)+' at i = '+str(i))
                Warnings=Warnings+1
                Warnings_code= np.append(Warnings_code, miss_tag)
                Warnings_pos=np.append(Warnings_pos,i)

        # Check start and question   code=42,17
        if Events_code[i,0]==46:
            if (Events_code [i+1,0]==42 or Events_code [i+1,0]==16 or Events_code [i+1,0]==17):
                pass
            elif (Events_code [i+1,0]==61 or Events_code[i+1,0]==62 or Events_code[i+1,0]==63 or Events_code[i+1,0]==64):
                print('Warning, miss Question at i = '+str(i))
                Warnings=Warnings+1
                Warnings_code= np.append(Warnings_code, 17)
                Warnings_pos=np.append(Warnings_pos,i)
            else:
                print('Warning, miss start at i = '+str(i))
                Warnings=Warnings+1
                Warnings_code= np.append(Warnings_code, 42)
                Warnings_pos=np.append(Warnings_pos,i)

        if (Events_code [i,0]==21 or Events_code[i,0]==22 or Events_code[i,0]==23):
            if Events_code [i+1,0]==42:
                pass
            else:
                print('Warning, miss start at i = '+str(i))
                Warnings=Warnings+1
                Warnings_code= np.append(Warnings_code, 42)
                Warnings_pos=np.append(Warnings_pos,i)


        if (Events_code [i,0]==61 or Events_code[i,0]==62 or Events_code[i,0]==63 or Events_code[i,0]==64):
            if (Events_code [i+1,0]==42 or Events_code [i+1,0]==16)  :
                pass
            else:
                print('Warning, miss start at i = '+str(i))
                Warnings=Warnings+1
                Warnings_code= np.append(Warnings_code, 42)
                Warnings_pos=np.append(Warnings_pos,i)

        # Check  code 44
        if (Events_code [i,0]==31 or Events_code [i,0]==32 or Events_code [i,0]==33 or Events_code [i,0]==34):
            if Events_code [i+1,0]==44:
                pass
            elif Events_code [i+1,0]==45:
                print('Warning, miss Usefull interval at i = '+str(i))
                Warnings=Warnings+1
                Warnings_code= np.append(Warnings_code, 44)
                Warnings_pos=np.append(Warnings_pos,i)


        # Check code 45
        if Events_code[i,0]==44:
            if Events_code [i+1,0]==45:
                pass
            elif Events_code [i+1,0]==46:
                print('Warning, miss Concentration interval at i = '+str(i))
                Warnings=Warnings+1
                Warnings_code= np.append(Warnings_code, 45)
                Warnings_pos=np.append(Warnings_pos,i)

        # Check Code 46
        if Events_code[i,0]==45:
            if Events_code [i+1,0]==46:
                pass
            else:
                print('Warning, miss Rest interval at i = '+str(i))
                Warnings=Warnings+1
                Warnings_code= np.append(Warnings_code, 46)
                Warnings_pos=np.append(Warnings_pos,i)


        # Check Ans Code 65
        if Events_code[i,0]==17:
            if (Events_code [i+1,0]==61 or Events_code[i+1,0]==62 or Events_code[i+1,0]==63 or Events_code[i+1,0]==64):
                pass
            else:
                print('Warning, miss Answerd at i = '+str(i))
                Warnings=Warnings+1
                Warnings_code= np.append(Warnings_code, 61)
                Warnings_pos=np.append(Warnings_pos,i)

# =============================================================================
# Correcting the events============================


    if Warnings==0:
        print('No Warnings, no corrections of events')
        Events_code_fix= Events_code
        Corrected_events=events
    else:
        print ("Correcting Events")
        # Adding missing values
        Warnings_code=np.delete(Warnings_code,0)
        Warnings_pos=np.delete(Warnings_pos,0)

        corrections=np.zeros([Warnings,3],dtype=int)

        corrections[:,2]=Warnings_code

        for i in range (len(corrections)):

               # If a 42 is missing, I was seaching after a 46
               if corrections[i,2]== 42:
                   corrections[i,0]=events[Warnings_pos[i],0]+1945;

               # If a 44 is missing, I was seaching after a 45
               elif corrections[i,2]== 44:
                   corrections[i,0]=events[Warnings_pos[i],0]+2594;

               #If a 44 is missing, I was seaching after a 46
               elif corrections[i,2]== 45:
                   corrections[i,0]=events[Warnings_pos[i],0]+1075;

               # If a 46 is missing, I was seaching after a 45 un 46
               elif corrections[i,2]== 46:
                   corrections[i,0]=events[Warnings_pos[i],0]+1075;

               # If a tag is missing, I was seaching after a 42
               elif corrections[i,2]== 17:
                   corrections[i,0]=events[Warnings_pos[i],0]+2092;

               # If a tag is missing, I was seaching after a 42
               elif corrections[i,2]== 61:
                   corrections[i,0]=events[Warnings_pos[i],0]+2092;
               # If a tag is missing, I was seaching after a 42
               elif corrections[i,2]== miss_tag:
                   corrections[i,0]=events[Warnings_pos[i],0]+563;


        #Append the missing events
        Corrected_events=np.append(events,corrections,axis=0)
        # Sort the events by the time stamp
        Corrected_events = Corrected_events[Corrected_events[:,0].argsort()]


#CHECK CORRECTED EVETS ===============================================
        Warnings=0
        Warnings_code=[0]
        Warnings_pos=[0]

        Events_code_fix=np.zeros([len(Corrected_events[:,2]) ,2],dtype=int)
        Events_code_fix[:,0]=Corrected_events[:,2]


        for i in range (len (Events_code_fix)):
            Events_code_fix[i,1]=i

            # Check Tags    code= 31 32 33 34
            # Find the star mark
            if Events_code_fix[i,0]==42:
                # If the next mark is the tag is OK
                if (Events_code_fix [i+1,0]==31 or Events_code_fix [i+1,0]==32 or Events_code_fix [i+1,0]==33 or Events_code_fix [i+1,0]==34):
                    pass
                # If the next mark is the mark for concentration the tag is missing
                elif Events_code_fix [i+1,0]==44:
                    # WORKS ONLY IF JUST ONE TAG IS MISSING !!!!
                    min_tag= min(Event_count[Event_count[:,0]==31,1],Event_count[Event_count[:,0]==32,1],Event_count[Event_count[:,0]==33,1],Event_count[Event_count[:,0]==34,1])
                    miss_tag=Event_count[Event_count[:,1]==min_tag,0]
                    print('Warnings, miss '+str(miss_tag)+' at i = '+str(i))
                    Warnings=Warnings+1
                    Warnings_code= np.append(Warnings_code, miss_tag)
                    Warnings_pos=np.append(Warnings_pos,i)

            # Check start      code=42
            if Events_code_fix[i,0]==46:
                if (Events_code_fix [i+1,0]==42 or Events_code_fix [i+1,0]==16 or Events_code_fix [i+1,0]==17):
                    pass
                else:
                    print('Warning, miss start at i = '+str(i))
                    Warnings=Warnings+1
                    Warnings_code= np.append(Warnings_code, 42)
                    Warnings_pos=np.append(Warnings_pos,i)

            if (Events_code_fix [i,0]==21 or Events_code_fix[i,0]==22 or Events_code_fix[i,0]==23):
                if Events_code_fix [i+1,0]==42:
                    pass
                else:
                    print('Warning, miss start at i = '+str(i))
                    Warnings=Warnings+1
                    Warnings_code= np.append(Warnings_code, 42)
                    Warnings_pos=np.append(Warnings_pos,i)


            if (Events_code_fix [i,0]==61 or Events_code_fix[i,0]==62 or Events_code_fix[i,0]==63 or Events_code_fix[i,0]==64):
                if (Events_code_fix [i+1,0]==42 or Events_code_fix [i+1,0]==16):
                    pass
                else:
                    print('Warning, miss start at i = '+str(i))
                    Warnings=Warnings+1
                    Warnings_code= np.append(Warnings_code, 42)
                    Warnings_pos=np.append(Warnings_pos,i)

            # Check usefull code 44
            if (Events_code_fix [i,0]==31 or Events_code_fix [i,0]==32 or Events_code_fix [i,0]==33 or Events_code_fix [i,0]==34):
                if Events_code_fix [i+1,0]==44:
                    pass
                elif Events_code_fix [i+1,0]==45:
                    print('Warning, miss Usefull interval at i = '+str(i))
                    Warnings=Warnings+1
                    Warnings_code= np.append(Warnings_code, 44)
                    Warnings_pos=np.append(Warnings_pos,i)


            # Check Usefull code 45
            if Events_code_fix[i,0]==44:
                if Events_code_fix [i+1,0]==45:
                    pass
                elif Events_code_fix [i+1,0]==46:
                    print('Warning, miss Concentration interval at i = '+str(i))
                    Warnings=Warnings+1
                    Warnings_code= np.append(Warnings_code, 45)
                    Warnings_pos=np.append(Warnings_pos,i)

            # Code 46
            if Events_code_fix[i,0]==45:
                if Events_code_fix [i+1,0]==46:
                    pass
                else:
                    print('Warning, miss Rest interval at i = '+str(i))
                    Warnings=Warnings+1
                    Warnings_code= np.append(Warnings_code, 46)
                    Warnings_pos=np.append(Warnings_pos,i)

            # Code 17
            if Events_code_fix[i,0]==17:
                if (Events_code_fix [i+1,0]==61 or Events_code_fix[i+1,0]==62 or Events_code_fix[i+1,0]==63 or Events_code_fix[i+1,0]==64):
                    pass
                else :
                    print('Warning, miss Answerd at i = '+str(i))
                    Warnings=Warnings+1
                    Warnings_code= np.append(Warnings_code, 61)
                    Warnings_pos=np.append(Warnings_pos,i)


        # correcting the events
        if Warnings==0:
            print('Taggs OK')

# CHECK FIXED EVENTS

    # Initialize vars
    Events_uniques_fix=np.unique(Events_code_fix[:,0]);

    Event_count_fix=np.zeros([len(Events_uniques_fix),2 ],dtype=int)
    Event_count_fix[:,0]= Events_uniques_fix

    # Count the events
    a=0
    for i in Events_uniques_fix:
       Event_count_fix[a,1]= len(np.extract(Events_code_fix[:,0]==Events_uniques_fix[a], Events_code_fix[:,0])  )
       a=a+1


# SANITY CHECK AFTER FIX EVETS ===============================================

    # Check if the Begining, End, Baseline start and end are OK
    if (Event_count_fix[Event_count_fix[:,0]==11,1]==1 and Event_count_fix[Event_count_fix[:,0]==12,1]==1 and Event_count_fix[Event_count_fix[:,0]==13,1]==1 and Event_count_fix[Event_count_fix[:,0]==14,1]==1):
        print('Start OK')
    else:
        raise Exception("Missing Stars")

    # Check if blocks are OK
    if Event_count_fix[Event_count_fix[:,0]==15,1] == Event_count_fix[Event_count_fix[:,0]==16,1] == Event_count_fix[Event_count_fix[:,0]==51,1]+1 :
        print('Blocks OK')
    else:
        raise Exception("Missing Blocks")

    # Check if Tags OK
    if Event_count_fix[Event_count_fix[:,0]==31,1] == Event_count_fix[Event_count_fix[:,0]==32,1] == Event_count_fix[Event_count_fix[:,0]==33,1] == Event_count_fix[Event_count_fix[:,0]==34,1]:
        print('Tags OK')
    else:
        raise Exception("Missing Tags")

    # Check if Marks OK
    if Event_count_fix[Event_count_fix[:,0]==42,1] == Event_count_fix[Event_count_fix[:,0]==44,1] == Event_count_fix[Event_count_fix[:,0]==45,1] == Event_count_fix[Event_count_fix[:,0]==46,1]:
        print('Marks OK')
    else:
        raise Exception("Missing Marks")

    # Check if Questions OK
    if len (Event_count_fix[Event_count_fix[:,0]==61,1])==0:
        Q_61 = 0
    else  :
        Q_61 = Event_count_fix[Event_count_fix[:,0]==61,1][0]

    if len (Event_count_fix[Event_count_fix[:,0]==62,1])==0:
        Q_62 = 0
    else  :
        Q_62 = Event_count_fix[Event_count_fix[:,0]==62,1][0]

    if len (Event_count_fix[Event_count_fix[:,0]==63,1])==0:
        Q_63 = 0
    else  :
        Q_63 = Event_count_fix[Event_count_fix[:,0]==63,1][0]

    if len (Event_count_fix[Event_count_fix[:,0]==64,1])==0:
        Q_64 = 0
    else  :
        Q_64 = Event_count_fix[Event_count_fix[:,0]==64,1][0]


    if Event_count_fix[Event_count_fix[:,0]==17,1][0] == (Q_61+Q_62+Q_63+Q_64 ):
        print('Cognitive control OK')
    else:
        raise Exception("Missing Congnitive Control Question/Answer")

    return Corrected_events

events = Event_correction (events=events)

"""# Replace the raw events with the new corrected events"""

rawdata.event = events
print(rawdata.event)

"""# Updating Report Dict"""

report['Recording_time'] = int(np.round(rawdata.last_samp/rawdata.info['sfreq']))

"""# Cognitive Control

Cognitive control refers to the mental processes and mechanisms that allow individuals to regulate and manage their thoughts, actions, and emotions in order to achieve specific goals. It involves the ability to flexibly adapt to changing demands, inhibit inappropriate responses, focus attention, and engage in goal-directed behavior.

Cognitive control in EEG involves neural processes that regulate mental functions during cognitive tasks. Event-related potentials (ERPs) and frequency bands like theta and alpha are analyzed to understand attention, memory, and control. Changes in amplitude and connectivity patterns provide insights into cognitive dynamics, with source localization identifying key brain regions such as the prefrontal cortex.
"""

def Cognitive_control_check(events):
    # Check Answers
    Ans_R=0;
    Ans_W=0;

    Events_uniques=np.unique(events[:,2])
    Event_count=np.zeros([len(Events_uniques),2 ],dtype=int)
    Event_count[:,0]= Events_uniques
    # Count the events
    a=0
    for i in Events_uniques:
       Event_count[a,1]= len(np.extract(events[:,2]==Events_uniques[a], events[:,2])  )
       a=a+1


    for i in range(len(events)):
       if  events[i,2]==17:
           if events[i+1,2]==events[i-4,2]+30:
               Ans_R=Ans_R+1
           else:
               Ans_W=Ans_W+1


    if Event_count[Event_count[:,0]==17,1] == Ans_R+Ans_W:
        if Event_count[Event_count[:,0]==17,1] == Ans_R:
            print('All Answers are OK')
        else:
            print('Warning, '+str(Ans_W)+' of ' + str(Event_count[Event_count[:,0]==17,1]) + ' Answers are wrong')
    else:
        raise Exception("Missing Congnitive Control Question/Answer")


    return Ans_R , Ans_W

report['Ans_R'] , report['Ans_W'] = Cognitive_control_check(events)

"""# EXG Channels for saving
The picks_types function is used to select channels based on their types, and in this case, channels labeled as EOG ('EXG1', 'EXG2', ..., 'EXG8') are used.

* **Extern channels**: EXG1, EXG2
* **Gaze detection**: EXG3, EXG4
* **Blinks detection**: EXG5, EXG6
* **Mouth Moving detection**: EXG7, EXG8


**Epochs**
The goal of using epochs is to isolate and analyze brain activity patterns associated with specific events or experimental conditions

In EEG data analysis, think of an "epoch" like a short movie clip captured from continuous brain recordings. Imagine you're watching a movie, and you mark specific moments—those are your events. An epoch is the snippet of the movie centered around each marked moment. It's like zooming in on the brain's activity during key events, helping scientists study how the brain responds to different situations.

"""

picks_eog = mne.pick_types(
    rawdata.info,
    eeg = False,
    stim = False,
    include = ['EXG1', 'EXG2', 'EXG3', 'EXG4', 'EXG5', 'EXG6', 'EXG7', 'EXG8'])

epochsEOG = mne.Epochs(
    rawdata,
    events,
    event_id = event_id,
    tmin = -0.5,
    tmax = 4,
    picks = picks_eog,
    preload = True,
    detrend = 0,
    decim = DS_rate)

"""##Epoching and decimating EEG
The data were decimated four times, obtaining a final sampling rate of 254 Hz. Then, the continuous recorded data were epoched, keeping only the 4.5 s length signals corresponding to the time window between the beginning of the concentration interval and the end of the relaxation interval. The matrices of dimension [channels × samples] corresponding to each trial, were stacked in a final tensor of size [trials × channels × samples].
"""

picks_eeg = mne.pick_types(
    rawdata.info,
    eeg=True,
    exclude=['EXG1', 'EXG2', 'EXG3', 'EXG4', 'EXG5', 'EXG6', 'EXG7', 'EXG8'],
    stim = False)

epochsEEG = mne.Epochs(
    rawdata,
    events,
    event_id = event_id,
    tmin = -0.5,
    tmax = 4,
    picks = picks_eeg,
    preload = True,
    detrend = 0,
    decim = DS_rate,
    baseline = None)

"""##  Independent Component Analysis (ICA)


Independent Component Analysis (ICA) is a signal processing technique used in EEG data analysis to separate a multichannel signal into additive, independent components.

The goal is to identify and remove artifacts from the EEG data, such as eye blinks, muscle activity, or other unwanted signals.


ICA is a powerful tool for enhancing the quality of EEG data by isolating and removing unwanted artifacts, allowing for a more accurate investigation of brain activity.

Here's a step-by-step explanation of ICA processing in the context of EEG data:

1. **Signal Decomposition:**
   - EEG data is collected from multiple channels, each recording a mix of neural and non-neural signals.
   - ICA decomposes the multichannel EEG signal into independent components, aiming to represent distinct underlying sources.

2. **Component Identification:**
   - Independent components represent different processes contributing to the recorded signals.
   - Some components correspond to neural activity, while others may represent artifacts like eye movements or muscle activity.

3. **Artifact Removal:**
   - Components related to artifacts are identified based on their spatial and temporal characteristics.
   - These artifact-related components can be removed, leaving behind the components associated with neural activity.

4. **Reconstruction:**
   - The cleaned EEG signal is reconstructed using the remaining independent components.
   - The reconstructed signal ideally reflects the neural activity, free from unwanted artifacts.

5. **Data Interpretation:**
   - Researchers and clinicians can now analyze the EEG data with increased confidence in the accuracy of the neural signals.


"""

# sir, represent
if ICA_bool:
    # Get a full trials including EXG channels
    picks_vir = mne.pick_types(
        rawdata.info,
        eeg=True,
        include=['EXG1', 'EXG2', 'EXG3', 'EXG4', 'EXG5', 'EXG6', 'EXG7', 'EXG8'],
        stim=False)
    epochsEEG_full=mne.Epochs(rawdata,
                              events,
                              event_id,
                              tmin=-0.5,
                              tmax=4,
                              picks=picks_vir,
                              preload=True,
                              detrend=0,
                              decim=DS_rate,
                              baseline = None)


    # Liberate Memory for ICA processing
    del rawdata

    # Creating the ICA object
    ica=mne.preprocessing.ICA(n_components=ICA_Components,random_state=ica_random_state, method=ica_method,fit_params=fit_params)

    # Fit ICA, calculate components
    ica.fit(epochsEEG)
    ica.exclude = []

    # Detect sources by correlation
    exg_inds_EXG3, scores_ica = ica.find_bads_eog(epochsEEG_full, ch_name='EXG3')  # find via correlation
    ica.exclude.extend(exg_inds_EXG3)

    # Detect sources by correlation
    exg_inds_EXG4, scores_ica = ica.find_bads_eog(epochsEEG_full, ch_name='EXG4')  # find via correlation
    ica.exclude.extend(exg_inds_EXG4)

            # Detect sources by correlation
    exg_inds_EXG5, scores_ica = ica.find_bads_eog(epochsEEG_full, ch_name='EXG5')  # find via correlation
    ica.exclude.extend(exg_inds_EXG5)

    # Detect sources by correlation
    exg_inds_EXG6, scores_ica = ica.find_bads_eog(epochsEEG_full, ch_name='EXG6')  # find via correlation
    ica.exclude.extend(exg_inds_EXG6)

    # Detect sources by correlation
    exg_inds_EXG7, scores_ica = ica.find_bads_eog(epochsEEG_full, ch_name='EXG7')  # find via correlation
    ica.exclude.extend(exg_inds_EXG7)

    # Detect sources by correlation
    exg_inds_EXG8, scores_ica = ica.find_bads_eog(epochsEEG_full, ch_name='EXG8')  # find via correlation
    ica.exclude.extend(exg_inds_EXG8)

    print("Appling ICA")
    ica.apply(epochsEEG)

"""# Create New Directory to Save File"""

save_dir= "/content/drive/MyDrive/FYPD_Dataset/saveDataNew"
def Ensure_dir(dir_name):
    import os
    if not os.path.exists(dir_name):
        os.makedirs(dir_name)

# file_path = save_dir + str(N_S) + '/ses-0'+ str(N_B)
file_path='/content/drive/MyDrive/FYPD_Dataset/saveData2/ses-01'
# Ensure_dir(file_path)

"""# **Save EEG FILE**"""

file_name = file_path + '/' +str(N_S)  + '_ses-0' + str(N_B) + '_eeg-epo.fif'
print(file_name)
# epochsEEG.save(file_name, fmt='double', split_size='2GB', overwrite=True)

"""# **Events_analysis**
1. Add_condition_tag
2. Add_block_tag
3. Delete_trigger
4. Standarized_labels

## **Add Condition Tag**
"""

def Add_condition_tag(events):

    # Create the tag Vector
    Mod_tag=0
    Mod=0
    for i in range(len(events)):

       if  events[i,2]==21:
           Mod=0

       if  events[i,2]==22:
           Mod=1

       if  events[i,2]==23:
           Mod=2

       Mod_tag = np.append(Mod_tag,Mod)

    Mod_tag= np.delete(Mod_tag,0)
    # Stack with the event matrix
    events_taged= np.hstack((events,Mod_tag[:,None]))

    events_taged=mne.pick_events(events_taged, include=[31,32,33,34])

    return events_taged

events = Add_condition_tag(events)

"""## **Add Block Tag**"""

def Add_block_tag(events, N_B):
    # Create the tag Vector
    Stage_tag=N_B*np.ones(events.shape[0],dtype=int)
    # Stack with the event matrix
    events_taged= np.hstack((events,Stage_tag[:,None]))

    return events_taged

events = Add_block_tag(events,N_B=N_B)

"""## **Delete Trigger**"""

def Delete_trigger(events):

    events=np.delete(events,1,axis =1)

    return events

events = Delete_trigger(events)

"""## **Standarized Labels**"""

def Standarized_labels(events):
    # Change the labels
    # 31 -> 0   "Arriba"    / "Up"
    # 32 -> 1   "Abajo"     / "Down"
    # 33 -> 2   "Derecha"   / "Rigth"
    # 34 -> 3   "Izquierda" / "Left"
    events[:,1]=events[:,1]-31

    return events

events = Standarized_labels(events)

"""## **Save events**"""

file_name = file_path + '/' +str(N_S) + '_ses-0' + str(N_B) + '_events.dat'
events.dump(file_name)

"""# **Ad hoc correction subject 3**
Subject S03 inform in block 1 he did not realice the inner speech paradigm. Instead he perform the visualized paradigm.
"""

def adhoc_Subject_3 (root_dir,verbose=True):

  if N_S == 1 and N_B == 3:
      Y_S3 = np.load(file_name, allow_pickle=True)

      # Correct the 40 trials where the subject executed a different paradigm
      Y_S3[80:120, 2] = 2

      if verbose:
          # Check if only 40 trials of Pronounced had left
          if (
              np.count_nonzero(Y_S3[:, 2] == 0) == 40
              and np.count_nonzero(Y_S3[:, 2] == 1) == 40
              and np.count_nonzero(Y_S3[:, 2] == 2) == 120
          ):
              print("AdHoc Correction Subject 3 Block 1")
          else:
              raise Exception("Correction fail")

      Y_S3.dump(file_name)

adhoc_Subject_3(root_dir=root_dir)

"""# **Load Events**


"""

def load_events():

    Num_s = str(N_S)
    # Create file Name
    events_dat_file_name = file_path + '/' +str(N_S)  + '_ses-0' + str(N_B) + '_events.dat'

    # Load Events
    events = np.load(events_dat_file_name,allow_pickle=True)

    return events

"""# **Data Extraction**

## **Extract Block Data From Subject**
"""

def Extract_block_data_from_subject(datatype):
    print(N_B)
    file_name = file_path + '/' +str(N_S)  + '_ses-0' + str(N_B) + '_eeg-epo.fif'
    # Get subject name
    Num_s = N_S

    # Get events
    Y = load_events()

    print(file_name,"this is file_name")
    if datatype == "eeg":
        #  load EEG data
        X = mne.read_epochs(file_name,verbose='WARNING')

    else:
        raise Exception("Invalid Datatype")

    return X, Y

print(Extract_block_data_from_subject("eeg"))

"""## **Extract data from subject**"""

def Extract_data_from_subject():

    """
    Load all blocks for one subject and stack the results in X
    """

    data=dict()
    y=dict()
    datatype="eeg"

    # name correction if N_Subj is less than 10

    y[N_B] = load_events()

    if datatype=="eeg":
      #  load data and events
      file_name = file_path + '/' +str(N_S)  + '_ses-0' + str(N_B) + '_eeg-epo.fif'
      X= mne.read_epochs(file_name,verbose='WARNING')
      data[N_B]= X._data

    else:
      raise Exception("Invalid Datatype")

    X = np.vstack((data.get(1)))


    Y = np.vstack((y.get(1)))


    return X, Y

"""```
`# This is formatted as code`
```

# **Data Processing**

## Filter By Condition
"""

def Filter_by_condition(X, Y, condition):
    if not condition:
        raise Exception("You have to select the conditions!")

    if condition.upper() == "ALL":
        return X, Y
    else:
        X_r = []
        Y_r = []
        if condition.upper() == "PRON" or condition.upper() == "PRONOUNCED":
            p = 0
        elif condition.upper() == "IN" or condition.upper() == "INNER":
            p = 1
        elif condition.upper() == "VIS" or condition.upper() == "VISUALIZED":
            p = 2
        else:
          raise Exception("The condition " + condition + " doesn't exist!")

        # X_r = X[X[:,2] == p]
        Y_r = Y[Y[:,2] == p]

    return X, Y_r

"""## Filter By Class"""

def Filter_by_class (X, Y, class_condition):
    if not class_condition:
        raise Exception("You have to select the classes for each condition!")

    if class_condition.upper() == "ALL":
        return X, Y
    else:
        X_r = []
        Y_r = []
        if class_condition.upper() == "UP" or class_condition.upper() == "ARRIBA":
          p = 0
        elif class_condition.upper() == "DOWN" or class_condition.upper() == "ABAJO":
          p = 1
        elif class_condition.upper() == "RIGHT" or class_condition.upper() == "DERECHA":
          p = 2
        elif class_condition.upper() == "LEFT" or class_condition.upper() == "IZQUIERDA":
          p = 3
        else:
          raise Exception("The class " + class_condition + " doesn't exist!")

        X_r = X[X[:,1] == p]
        Y_r = Y[Y[:,1] == p]

    return X , Y_r

"""# **Utilitys**

## Unify Names
"""

def unify_names(Cond, Class):

    if Cond == "inner" or Cond == "In":
        Cond = "Inner"

    if Cond == "vis" or Cond == "Visualized":
        Cond = "Vis"

    if Cond == "pron" or Cond == "Pronounced":
        Cond = "Pron"

    if Class == "all" or Class == "Todo" or Class == "todo":
        Class = "All"

    if Class == "up" or Class == "Arriba" or Class == "arriba":
        Class = "Up"

    if Class == "down" or Class == "Abajo" or Class == "abajo":
        Class = "Down"

    if Class == "right" or Class == "Derecha" or Class == "derecha":
        Class = "Right"

    if Class == "left" or Class == "Izquierda" or Class == "izquierda":
        Class = "Left"

    return Cond, Class

def EMG_control_single_th(root_dir,N_Subj_arr,N_block_arr,low_f,high_f,t_min,t_max,window_len,window_step,std_times,t_min_baseline,t_max_baseline,tag_events=False,verbose=False):


    # Imports
    import numpy as np
    import pickle
    from Data_processing import  Calculate_power_windowed
    from Data_extractions import  Extract_block_data_from_subject, Extract_report

    # Trials of Pronounced condition are excluded in the EMG control
    Pronunced_id=0

    # In[]
    # Subjets
    for N_S in N_Subj_arr:
        if N_S<10:
            Num_s = 'sub-0' + str(N_S)
        else:
            Num_s = 'sub-' + str(N_S)

        # Blocks
        for N_B in N_block_arr:
            #Load baseline data
            datatype = "Baseline"
            X_baseline , Y = Extract_block_data_from_subject(root_dir, N_S, datatype, N_B)

            X_baseline.filter(low_f,high_f)

            FC=int(X_baseline.info['sfreq'])
# =============================================================================
# =============================================================================
            # EXG7 Control
            Baseline = X_baseline.copy()
            # Select only EMG 1 channels
            Baseline = Baseline.pick_channels(["EXG7"])
            # Extract data
            Channel_filter = Baseline.get_data()
            Channel_filter = Channel_filter[0,0,:]
            # Rectified signal
            Channel_filter = np.abs(Channel_filter)
            # Calculate mean and std for channel 7
            mean_Base_energy_7 , std_Base_energy_7 = Calculate_power_windowed(Channel_filter, FC, window_len,
                                                                               window_step, t_min_baseline,
                                                                               t_max_baseline)
# =============================================================================
            # EXG7 Control
            Baseline = X_baseline.copy()
            Baseline.pick_channels(["EXG8"])
            # Extract data
            Channel_filter = Baseline.get_data()
            Channel_filter = Channel_filter[0,0,:]
            # Rectified signal
            Channel_filter = np.abs(Channel_filter)

            # Calculate mean and std for channel 8
            mean_Base_energy_8 , std_Base_energy_8 = Calculate_power_windowed(Channel_filter, FC, window_len,
                                                                               window_step, t_min_baseline,
                                                                               t_max_baseline)
            del Baseline, X_baseline
# =============================================================================
# =============================================================================
            #Load EOG and EMG data
            datatype = "EXG"
            EMG , Y = Extract_block_data_from_subject(root_dir, N_S, datatype, N_B)

            #Filter in the same band
            EMG.filter(low_f,high_f)

            #Copy data
            EMG_EXG7 = EMG.copy()
            EMG_EXG8 = EMG.copy()

            # Select channel
            EMG_EXG7.pick_channels(["EXG7"])
            # Extract data
            EMG_data_EXG7 = EMG_EXG7.get_data()
            EMG_data_EXG7 = np.abs(EMG_data_EXG7)
            # Select channel
            EMG_EXG8.pick_channels(["EXG8"])
             # Extract data
            EMG_data_EXG8 = EMG_EXG8.get_data()
            EMG_data_EXG8 = np.abs(EMG_data_EXG8)

            # Initialized the taggin vector
            EMG_reject = np.zeros(EMG._data.shape[0])
            del EMG , EMG_EXG7 , EMG_EXG8
# =============================================================================
            # In[]: Tagging
            # Initialization
            drop_epoched = []
            trial_power_7 = []
            trial_power_8 = []

            # Get number of trials
            Trials, Channels, samples = EMG_data_EXG8.shape

            # Calculated the threshold for anotated the trial
            threshold_7 = mean_Base_energy_7 + (std_times * std_Base_energy_7)
            threshold_8 = mean_Base_energy_8 + (std_times * std_Base_energy_8)

            for n_trial in range(Trials):

                # Get trial
                Channel_filter=EMG_data_EXG7[n_trial,0,:]
                # Calculate power for channel EXG7
                mean_Trial_Energy_7 , std_trial_energy_7 = Calculate_power_windowed(Channel_filter, FC, window_len,
                                                                                     window_step, t_min, t_max)

                # Get trial
                Channel_filter=EMG_data_EXG8[n_trial,0,:]
                # Calculate power for channel EXG8
                mean_Trial_Energy_8 , std_trial_energy_8 = Calculate_power_windowed(Channel_filter, FC, window_len,
                                                                                     window_step, t_min, t_max)

                # Threshold condition
                if (mean_Trial_Energy_8>threshold_8 or mean_Trial_Energy_7>threshold_7):

                    # mark only if is not Pronounced trials
                    if not(Y[n_trial,2] == Pronunced_id):

                        trial_power_7 = np.append(trial_power_7,mean_Trial_Energy_7)
                        trial_power_8 = np.append(trial_power_8,mean_Trial_Energy_8)
                        drop_epoched = np.append(drop_epoched,n_trial)
                        EMG_reject[n_trial] = 1

                        if verbose:
                            print ("Warnign at trial", n_trial+1)

            # In[]: Update Report
            R_EMG = np.vstack([drop_epoched,trial_power_7,trial_power_8])
            R_EMG = np.transpose(R_EMG)

            print('Tagged Trials: '+str(len(R_EMG)),'for Subject ' +str(N_S)+' in Session '+str(N_B))

            # Update Report
            report = Extract_report(root_dir,N_B,N_S)

            report['EMG_trials'] = R_EMG[:,0]
            report['Power_EXG7'] = R_EMG[:,1]
            report['Power_EXG8'] = R_EMG[:,2]

            report['Baseline_EXG7_mean'] = mean_Base_energy_7
            report['Baseline_EXG8_mean'] = mean_Base_energy_8

            report['Baseline_EXG7_std'] = std_Base_energy_7
            report['Baseline_EXG8_std'] = std_Base_energy_8

            # Save report
            file_name = root_dir + 'derivatives/' + Num_s + '/ses-0'+ str(N_B) + '/' +Num_s+'_ses-0'+str(N_B)+'_report.pkl'
            with open(file_name, 'wb') as output:
                pickle.dump(report, output, pickle.HIGHEST_PROTOCOL)

    print("EMG Control Done")